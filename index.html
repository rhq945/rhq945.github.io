<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/26/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">形式语言自动机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-26 09:54:38 / Modified: 10:10:45" itemprop="dateCreated datePublished" datetime="2021-07-26T09:54:38+08:00">2021-07-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h2><h3 id="形式语言定义"><a href="#形式语言定义" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>自动机：具有离散输入输出的数学模型</p>
<h3 id="⭐对应关系"><a href="#⭐对应关系" class="headerlink" title="⭐对应关系"></a>⭐对应关系</h3><p>非限定性语言        —————        图灵机 </p>
<p>上下文有关语言    —————        线性有界自动机 </p>
<p>上下文无关语言    —————        下推式自动机</p>
<p>正则语言               —————        有限自动机 </p>
<h2 id="2-语言及文法"><a href="#2-语言及文法" class="headerlink" title="2.语言及文法"></a>2.语言及文法</h2><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>字符串：简称为‘字’或者‘串’，是由字母表T中字符构成的有限序列</p>
<p>连接</p>
<p>取头字符,取尾部,子串匹配</p>
<p>逆:字符串倒置：w~1~=a~1~a~2~a~3~—&gt;w~1~上有一横=a~3~a~2~a~1~</p>
<p>幂运算:自身连接 ，T^0^={ε}</p>
<p>闭包(<em>,+):</em>闭包包括{ε}，+闭包不包括</p>
<h3 id="语言："><a href="#语言：" class="headerlink" title="语言："></a>语言：</h3><p><u>注意：L~1~={ε}和L2={}=Φ不一样，前者是只有一个空句子的语言，后者是空语言</u></p>
<h4 id="语言的积"><a href="#语言的积" class="headerlink" title="语言的积"></a>语言的积</h4><p>L~1~={ ab , ba },L~2~={  aa , bb };则L~1~L~2~={abaa,abbb,baaa,babb};L~1~L~2~ ≠ L~2~L~1~.</p>
<h4 id="语言的幂"><a href="#语言的幂" class="headerlink" title="语言的幂"></a>语言的幂</h4><p>自身连接</p>
<h3 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h3><h4 id="四元组G-N-T-P-S"><a href="#四元组G-N-T-P-S" class="headerlink" title="四元组G={N,T,P,S}"></a>四元组G={<em>N,T,P,S</em>}</h4><p>L(G)是文法生成的句子</p>
<p><em>N</em>:非终结符的有限集合</p>
<p><em>T</em>: 终结符的有限集合</p>
<p><em>P</em>: 生成式的有限集合</p>
<p><em>S</em>: 起始符，<em>S</em>∈<em>N</em></p>
<h3 id="文法分类："><a href="#文法分类：" class="headerlink" title="文法分类："></a>文法分类：</h3><h4 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h4><p>无限制</p>
<h4 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h4><pre><code>α--&gt;β,其中|α|&lt;|β|, β∈(N∪T)^+^,α∈(N∪T)^*^N^+^(N∪T)^*^，即意味着左边必须至少有一个起始符，右边可以起始也可以不起始，但右边长度必须不小于左边长度。对应语言：上下文有关语言
</code></pre><h4 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h4><pre><code>A--&gt;α，A∈N，α∈(N∪T)^*^，即意味着左边必须是一个起始符，右边无限制，但长度不小于1（满足1型文法）。对应语言：上下文无关语言
</code></pre><h4 id="3型文法-正则文法"><a href="#3型文法-正则文法" class="headerlink" title="3型文法/正则文法"></a>3型文法/正则文法</h4><pre><code>右线性文法：

    A--&gt;wB 或 A--&gt;w   A,B∈N，w∈T^*^.

左线性文法：

    A--&gt;Bw 或 A--&gt;w   A,B∈N，w∈T^*^.

对应语言：正则语言
</code></pre><h2 id="3-有限自动机和右线性文法"><a href="#3-有限自动机和右线性文法" class="headerlink" title="3.有限自动机和右线性文法"></a>3.有限自动机和右线性文法</h2><h3 id="3-1确定的有限自动机DFA"><a href="#3-1确定的有限自动机DFA" class="headerlink" title="3.1确定的有限自动机DFA"></a>3.1确定的有限自动机DFA</h3><p>五元组 = ( Q , T , δ , q~0~ , F )</p>
<p>Q x T —&gt; Q.</p>
<p>切记：不管是转移图还是转移表表示DFA时，<u>都要注意初始状态和终止状态</u>。初始状态前有箭头，终止状态               有双圈。</p>
<p>被DFA接受的字符串必须在输入结束后能够使DFA状态达到终止</p>
<h4 id="格局"><a href="#格局" class="headerlink" title="格局"></a>格局</h4><p>包括信息：当前状态q，待输入字符串w. 两者构成的瞬时描述 ( q , w )</p>
<p>初始格局：( q~0~ , w )</p>
<p>终止格局： ( q , ε ), q∈F</p>
<p><img src="https://img-blog.csdnimg.cn/20210425104536664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" /></p>
<h4 id="设计有限自动机："><a href="#设计有限自动机：" class="headerlink" title="设计有限自动机："></a>设计有限自动机：</h4><h5 id="多个例子"><a href="#多个例子" class="headerlink" title="多个例子"></a>多个例子</h5><p><img src="https://img-blog.csdnimg.cn/2021042510455461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><br><img src="https://img-blog.csdnimg.cn/20210425104602388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /><br><img src="https://img-blog.csdnimg.cn/20210425104605844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<h3 id="3-2-不确定有限自动机：NFA"><a href="#3-2-不确定有限自动机：NFA" class="headerlink" title="3.2 不确定有限自动机：NFA"></a>3.2 不确定有限自动机：NFA</h3><h4 id="五元组：NFA-M-Q-T-δ-q-0-F"><a href="#五元组：NFA-M-Q-T-δ-q-0-F" class="headerlink" title="五元组：NFA M = ( Q , T , δ , q~0~ , F )"></a>五元组：NFA M = ( Q , T , δ , q~0~ , F )</h4><p>其中δ = Q x T —&gt;2^Q^</p>
<p>DFA是特殊的NFA ，NFA转化DFA：</p>
<h4 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h4><p>列表法进行，注意以下几点：</p>
<p>表中的状态集合要在中括号中。例：[ p ]，[ q , r ];</p>
<p>表中的起始状态要加箭头，终止状态要加星号*</p>
<p>最后的图中状态集合要在大括号中。例：{ q }, { q , r },同时外加圆圈，终止状态双重圆圈</p>
<h3 id="3-3-ε-NFA"><a href="#3-3-ε-NFA" class="headerlink" title="3.3 ε-NFA"></a>3.3 ε-NFA</h3><h4 id="五元组：NFA-M-Q-T-δ-q-0-F-1"><a href="#五元组：NFA-M-Q-T-δ-q-0-F-1" class="headerlink" title="五元组：NFA M = ( Q , T , δ , q~0~ , F )"></a>五元组：NFA M = ( Q , T , δ , q~0~ , F )</h4><p>其中δ = Q x( T ∪{ ε }) —&gt; 2^Q^</p>
<h4 id="ε闭包"><a href="#ε闭包" class="headerlink" title="ε闭包"></a>ε闭包</h4><p>ε-CLOSURE或ECLOSE，定义为从q经过所有的ε路径可到达状态，包括q自身</p>
<p>状态子集的ε-闭包：ε-CLOSURE( I ) = ∪ε-CLOSURE( q ),q∈I</p>
<p>Ia定义：对于状态子集 I ⊆ Q,任意 a ∈ T，Ia = ε-CLOSURE( δ ( I , a ) ) .</p>
<p>定义P = δ ( I , a ):P是从I中的所有状态经过一条标a的边可以到达的状态集合</p>
<p>计算δ’ ( q~0~ , a ):</p>
<p>δ’ ( q~0~ , a ) = ε-CLOSURE{ δ [ δ’ ( q~0~ , ε ) , a ] }</p>
<p>​                 = ε-CLOSURE{ δ [ ε-CLOSURE(q~0~) , a ] } </p>
<p>//先求一个q~0~的ε-闭包，再将其闭包后的结果全部经过一个a形成的集合，再将其集合中的元素全部进行ε-闭包得到集合即为最终答案。</p>
<h4 id="构造ε-NFA自动机"><a href="#构造ε-NFA自动机" class="headerlink" title="构造ε-NFA自动机"></a>构造ε-NFA自动机</h4><p><img src="https://img-blog.csdnimg.cn/20210425104952819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h5 id="ε-NFA自动机格局"><a href="#ε-NFA自动机格局" class="headerlink" title="ε-NFA自动机格局"></a>ε-NFA自动机格局</h5><p><img src="https://img-blog.csdnimg.cn/20210425104646931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h4 id="ε-NFA转化NFA"><a href="#ε-NFA转化NFA" class="headerlink" title="ε-NFA转化NFA"></a>ε-NFA转化NFA</h4><h5 id="ε闭包法："><a href="#ε闭包法：" class="headerlink" title="ε闭包法："></a>ε闭包法：</h5><p><img src="https://img-blog.csdnimg.cn/20210425104701441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<p>一个一个找，从起始状态开始将ε路径跳过(空跳)，比如从X跳到A，那么A接受1到B，就可以看成X接受1到B，既然X可以空跳经过G，那么讨论完X之后就不再讨论G。</p>
<p><img src="https://img-blog.csdnimg.cn/20210425104713172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h3 id="3-4-正则集和正则式"><a href="#3-4-正则集和正则式" class="headerlink" title="3.4 正则集和正则式"></a>3.4 正则集和正则式</h3><h4 id="正则集"><a href="#正则集" class="headerlink" title="正则集"></a>正则集</h4><p>字母表上一些特殊形式的字符串集合</p>
<p>{ε} , Φ , {a}都是正则集</p>
<h4 id="正则式"><a href="#正则式" class="headerlink" title="正则式"></a>正则式</h4><p>用类似代数表达式的方法表示正则语言</p>
<p>ε , Φ , a(a∈T)都是正则式</p>
<h4 id="运算：作用于语言上的代数运算"><a href="#运算：作用于语言上的代数运算" class="headerlink" title="运算：作用于语言上的代数运算"></a>运算：作用于语言上的代数运算</h4><p>若A,B为正则式，L{ A } , L{ B }为正则集</p>
<p>联合：A+B   或者   L { A } ∪ L { B } 或者的关系，若之后没有*闭包运算，则A,B不能共存，每次只出现一个</p>
<p>连接：AB   或者   L{ A } · L{ B }  顺序的关系</p>
<p>星闭包：A<em>  或者 L(A)</em> </p>
<p>算数符优先级：* 大于 · 大于 +</p>
<h4 id="正则式的性质"><a href="#正则式的性质" class="headerlink" title="正则式的性质"></a>正则式的性质</h4><p>L^+^一定不包含ε吗？不一定，如果L中包含ε，那么L^+^也可以包含ε.</p>
<h5 id="与闭包有关的定律"><a href="#与闭包有关的定律" class="headerlink" title="与闭包有关的定律"></a>与闭包有关的定律</h5><p>(a^<em>^)^</em>^=a^<em>^,  a^</em>^=a+a^<em>^, L^+^=LL^</em>^=L^<em>^L, L^</em>^=L^+^∪{ε}</p>
<h4 id="右线性文法与正则式"><a href="#右线性文法与正则式" class="headerlink" title="右线性文法与正则式"></a>右线性文法与正则式</h4><p>两者等效</p>
<p>文法 S —&gt; aS,  S —&gt; a</p>
<p>对应正则式 a^+^ = a*a</p>
<h5 id="从右线性文法导出正则式："><a href="#从右线性文法导出正则式：" class="headerlink" title="从右线性文法导出正则式："></a>从右线性文法导出正则式：</h5><h6 id="求解规则"><a href="#求解规则" class="headerlink" title="求解规则"></a>求解规则</h6><p>设x=αx+β，α∈T^<em>^，β∈(N∪T)^</em>^,x∈N，则x的解为x=α^*^β</p>
<h6 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h6><p>将右线性文法的生成式写成联立方程，将所有的大写字母当作未知数求解</p>
<h3 id="3-5-正则集与右线性文法"><a href="#3-5-正则集与右线性文法" class="headerlink" title="3.5 正则集与右线性文法"></a>3.5 正则集与右线性文法</h3><h4 id="正则集-lt-gt-右线性文法产生的语言"><a href="#正则集-lt-gt-右线性文法产生的语言" class="headerlink" title="正则集&lt;==&gt;右线性文法产生的语言"></a>正则集&lt;==&gt;右线性文法产生的语言</h4><h5 id="已知正则集，求右线性文法："><a href="#已知正则集，求右线性文法：" class="headerlink" title="已知正则集，求右线性文法："></a>已知正则集，求右线性文法：</h5><h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>设正则集L为含有两个相继a和两个相继b的由a和b组成的所有字符串集合，构造产生L的右线性文法</p>
<h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><h5 id="先得出正则式"><a href="#先得出正则式" class="headerlink" title="先得出正则式"></a>先得出正则式</h5><p>提炼核心内容：必须有aa和bb，所以可能是aabb，bbaa。</p>
<p>确定其余部分：(a+b)^*^</p>
<p>得出正则式：(a+b)^<em>^aa(a+b)^</em>^bb(a+b)^<em>^ + (a+b)^</em>^bb(a+b)^<em>^aa(a+b)^</em>^</p>
<h5 id="根据正则式得出右线性文法"><a href="#根据正则式得出右线性文法" class="headerlink" title="根据正则式得出右线性文法"></a>根据正则式得出右线性文法</h5><h6 id="分解规则"><a href="#分解规则" class="headerlink" title="分解规则"></a>分解规则</h6><p>需要从左侧开始分解</p>
<p>对于aX的形式，可以转化为S—&gt;aX</p>
<p>对于(a+b)X的形式，可以转化为S—&gt;aX|bX</p>
<p>对于a*的形式，可以转化为S—&gt;aS</p>
<h6 id="逐步分解"><a href="#逐步分解" class="headerlink" title="逐步分解"></a>逐步分解</h6><p>首先，对(a+b)^*^（相当于提公因式），有S—&gt;aS|bS</p>
<p>然后，对于剩下的aa(a+b)^<em>^bb(a+b)^</em>^和bb(a+b)^<em>^aa(a+b)^</em>^，因为是两部分相加得到，所以有S—&gt;aaA|bbB</p>
<p>其中，A = (a+b)^<em>^bb(a+b)^</em>^，B = (a+b)^<em>^aa(a+b)^</em>^</p>
<p>先研究A，对于(a+b)^*^，有A—&gt;aA|bA</p>
<p>剩下bb(a+b)^<em>^，有A—&gt;bbC,其中C=(a+b)^</em>^</p>
<p>所以C—&gt;aC|bC|ε</p>
<p>同理，B—&gt;aB|bB|aaC</p>
<h6 id="得出答案"><a href="#得出答案" class="headerlink" title="得出答案"></a>得出答案</h6><p>S—&gt;aS|bS|aaA|bbB</p>
<p>A—&gt;aA|bA|bbC</p>
<p>B—&gt;aB|bB|aaC</p>
<p>C—&gt;aC|bC|ε</p>
<h3 id="3-7-正则表达式与有限自动机的关系"><a href="#3-7-正则表达式与有限自动机的关系" class="headerlink" title="3.7 正则表达式与有限自动机的关系"></a>3.7 正则表达式与有限自动机的关系</h3><h4 id="从DFA构造正则表达式"><a href="#从DFA构造正则表达式" class="headerlink" title="从DFA构造正则表达式"></a>从DFA构造正则表达式</h4><h5 id="状态消去法"><a href="#状态消去法" class="headerlink" title="状态消去法"></a>状态消去法</h5><p>消去的是中间状态，即除了起始和终止都要消去</p>
<p>最终得到的正则表达式为每一终态对应的正则表达式之和</p>
<h5 id="消去规则"><a href="#消去规则" class="headerlink" title="消去规则"></a>消去规则</h5><p><img src="https://img-blog.csdnimg.cn/2021042510473746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<p>例1</p>
<p><img src="https://img-blog.csdnimg.cn/2021042510474488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<p>例2</p>
<p><img src="https://img-blog.csdnimg.cn/20210425104750574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h4 id="从正则式构造等价ε-NFA"><a href="#从正则式构造等价ε-NFA" class="headerlink" title="从正则式构造等价ε-NFA"></a>从正则式构造等价ε-NFA</h4><h5 id="归纳构造过程"><a href="#归纳构造过程" class="headerlink" title="归纳构造过程"></a>归纳构造过程</h5><p>对于R+S:</p>
<p><img src="https://img-blog.csdnimg.cn/20210425104802981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<p>对于RS</p>
<p><img src="https://img-blog.csdnimg.cn/20210425104813882.png" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<p>对于R*</p>
<p><img src="https://img-blog.csdnimg.cn/20210425104819942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="https://img-blog.csdnimg.cn/20210425104829142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h3 id="3-8-右线性语言与有限自动机"><a href="#3-8-右线性语言与有限自动机" class="headerlink" title="3.8 右线性语言与有限自动机"></a>3.8 右线性语言与有限自动机</h3><p>由右线性文法G定义的语言必然能被一个NFA M所接受。即L(G) = L(M)</p>
<h4 id="构造与右线性文法等价的有限自动机"><a href="#构造与右线性文法等价的有限自动机" class="headerlink" title="构造与右线性文法等价的有限自动机"></a>构造与右线性文法等价的有限自动机</h4><h5 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h5><p>设有右线性文法G=({S, B} , {a, b} , P , S),其中 P:S—&gt;aB     B—&gt;aB|bS|a， 试着构造与G等价的有限自动机M</p>
<h5 id="答题步骤"><a href="#答题步骤" class="headerlink" title="答题步骤"></a>答题步骤</h5><h6 id="构造NFA-M"><a href="#构造NFA-M" class="headerlink" title="构造NFA M"></a>构造NFA M</h6><p> M = ( Q , T , δ , q~0~ , F ) ,</p>
<h6 id="将Q-T-q-0-F-全部表明清楚"><a href="#将Q-T-q-0-F-全部表明清楚" class="headerlink" title="将Q , T , q~0~ , F 全部表明清楚"></a>将Q , T , q~0~ , F 全部表明清楚</h6><p>注意Q中要多一个H作为终止状态:  Q = { S, B, H }，T = { a, b },  q~0~ = S, F = { H }</p>
<h6 id="构造转换函数δ"><a href="#构造转换函数δ" class="headerlink" title="构造转换函数δ"></a>构造转换函数δ</h6><p>每个产生式都对应一个δ</p>
<p>对 S—&gt;aB，有 δ(S,a) = {B}</p>
<p>对 B—&gt;aB，有 δ(B,a) = {B}</p>
<p>对 B—&gt;bS，有 δ(B,b) = {S}</p>
<p>对 B—&gt;a，  有 δ(B,a) = {H}</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>构造δ时，只有在形如S—&gt;aB时能使用，即右边不能超过两个字母表中字母。如果出现S—&gt;abB，则必须新构造一个状态，使得S—&gt;aC, C—&gt;bB. </p>
<h3 id="3-9-3-10右线性语言的性质"><a href="#3-9-3-10右线性语言的性质" class="headerlink" title="3.9-3.10右线性语言的性质"></a>3.9-3.10右线性语言的性质</h3><h4 id="DFA极小化"><a href="#DFA极小化" class="headerlink" title="DFA极小化"></a>DFA极小化</h4><h5 id="等价状态"><a href="#等价状态" class="headerlink" title="等价状态"></a>等价状态</h5><p>DFA M = ( Q , T , δ , q~0~ , F ) , 对于任意两个状态q~1~q~2~∈Q和每个w∈T^<em>^，若有：(q~1~ , w)|-^</em>^(q,ε)&lt;==&gt;(q~1~ , w)|-^*^(q,ε)且q∈F，则称q~1~与q~2~等价，记作q~1~≡q~2~</p>
<h5 id="不可达状态"><a href="#不可达状态" class="headerlink" title="不可达状态"></a>不可达状态</h5><p>不存在任何w∈T^<em>^，能够使(q~0~ , w)|-^</em>^(q,ε)，则称 q∈Q 为不可达状态</p>
<h4 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h4><p>若DFA M不存在互为等价状态和不可达状态，则称 DFA M 为最小化的</p>
<h5 id="最小化算法—填表法"><a href="#最小化算法—填表法" class="headerlink" title="最小化算法—填表法"></a>最小化算法—填表法</h5><h6 id="确定不可达状态"><a href="#确定不可达状态" class="headerlink" title="确定不可达状态"></a>确定不可达状态</h6><p>将不可达状态删除</p>
<h6 id="区别终态"><a href="#区别终态" class="headerlink" title="区别终态"></a>区别终态</h6><p>终态与非终态不可能为等价状态</p>
<h6 id="合并等价态"><a href="#合并等价态" class="headerlink" title="合并等价态"></a>合并等价态</h6><p>划分结果时，互为等价态的状态集是用打大括号括起来，最后得出新的状态集合时，每个等价态只用一个状态表示，最后的状态集合每个状态都用中括号括起来</p>
<h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20210425104849914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></h5><p><img src="https://img-blog.csdnimg.cn/20210425104854244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h4 id="泵浦定理"><a href="#泵浦定理" class="headerlink" title="泵浦定理"></a>泵浦定理</h4><p>设L是正则集，存在常数K，对字符串w∈L且 | w | &gt;= n，则 w 可以写成 w~1~w~0~w~2~ ，其中 | w~1~w~0~ | &lt;= n，| w~0~ | &gt; 0，对于所有的 i &gt;= 0 ，有 w~1~w~0~^i^w~2~∈L。//所以 w~0~ 一定是在字符串的前n个字符中找。</p>
<h5 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h5><p>求证L={a^k^| k &gt;= 1}不是正则集</p>
<h5 id="回答规范"><a href="#回答规范" class="headerlink" title="回答规范"></a>回答规范</h5><p>假设L是正则集，取足够大的整数n，w = a^n^。有| w |=| w~1~w~0~w~2~ | = n平方 &gt;= n。</p>
<p>因为 | w~1~w~2~ | &lt;= n，| w~0~ | &gt; 0，若取 i = 2，则 的情况为| w~1~w~0~w~0~w~2~ |=| w |+| w~0~ |, | w | = n平方,   0 &lt; | w~0~ | &lt;= n, 所以        n平方 &lt; | w | + | w~0~ | &lt;= n平方+n &lt; (n+1)平方,所以不满足w = a的n^2^次方（串长不是整数平方），所以与假设冲突。</p>
<p>像这个例子是使用了类似于逻辑归纳法的方式来进行反证的。看下一个例子</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>L={ w | w中0和1的个数相等 }不是正则集</p>
<p>在证明这个L时，我们选取了 0^n^1^n^这样一个特殊条件来进行判断，在判断不是正则集后即可将L全部否定。</p>
<h4 id="右线性语言的封闭性"><a href="#右线性语言的封闭性" class="headerlink" title="右线性语言的封闭性"></a>右线性语言的封闭性</h4><p>L~1~和L~2~是右线性语言，则L~I~∪L~2~，L~1~L~2~，L~1~*，L~1~的补集(就是在L~1~上面画横杠)L~1~∩L~2~都是右线性语言。</p>
<h5 id="双向有限自动机"><a href="#双向有限自动机" class="headerlink" title="双向有限自动机"></a>双向有限自动机</h5><p>读入一个字符以后，读头可以：左移右移不动</p>
<p>形式定义：2DFA M = ( Q , T , σ , q~0~ , F )</p>
<p>设有w~1~qw~2~ ， w~1~为已输入串   q为当前状态    w~2~为待输入串 </p>
<p>σ(q,a~m+1~)=(p,R)(R说明右移)   格局描述：a~1~ a~2~  … a~m~ q a~m+1~… |- a~1~ a~2~  … a~m~ a~m+1~ q a~m+2~ …</p>
<p>σ(q,a~m+1~)=(p,L)(L说明左移)   格局描述：a~1~ a~2~  … a~m~ q a~m+1~… |- a~1~ a~2~  …  a~m-1~ q a~m~ …</p>
<p>2DFA 接受的字符串集合：{w | q~0~w |-* wq , q∈F }</p>
<h6 id="确定的双向有限自动机"><a href="#确定的双向有限自动机" class="headerlink" title="确定的双向有限自动机"></a>确定的双向有限自动机</h6><p>不能不动</p>
<h5 id="有输出的有限自动机"><a href="#有输出的有限自动机" class="headerlink" title="有输出的有限自动机"></a>有输出的有限自动机</h5><p>形式定义  （Q , T , R , σ , g , q~0~)</p>
<p>T：有限输入字母表 ；  R：有限输出字母表 ；   σ：转换函数 Q×T—&gt;Q   ；  q~0~：初始状态</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>米兰机</th>
<th>摩尔机</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>输出字符与输入字符及状态有关</td>
<td>输出字符仅与状态有关</td>
</tr>
<tr>
<td>g 输出函数</td>
<td>Q×T—&gt;R</td>
<td>Q—&gt;R</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://img-blog.csdnimg.cn/20210425104907658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5ODMxMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" /></p>
<h2 id="4-上下文无关文法与下推自动机"><a href="#4-上下文无关文法与下推自动机" class="headerlink" title="4.上下文无关文法与下推自动机"></a>4.上下文无关文法与下推自动机</h2><h3 id="4-1推导树和二义性"><a href="#4-1推导树和二义性" class="headerlink" title="4.1推导树和二义性"></a>4.1推导树和二义性</h3><h5 id="归约与推导"><a href="#归约与推导" class="headerlink" title="归约与推导"></a>归约与推导</h5><p>G=(N,T,P,S)=( { <em>E,O</em> } , { <em>*,+,v,d,(,)</em> } , P , E ),已知字符串v*(v+d)</p>
<p>归约：字符串v*(v+d)推导回E</p>
<p>推导：E推导到字符串v*(v+d)</p>
<h6 id="最左推导"><a href="#最左推导" class="headerlink" title="最左推导"></a>最左推导</h6><p>推导过程的每一步总是替换出现在<u><strong>最左边</strong></u>的<u><strong>非终结符</strong></u></p>
<h6 id="最右推导"><a href="#最右推导" class="headerlink" title="最右推导"></a>最右推导</h6><p>推导过程的每一步总是替换出现在<u><strong>最右边</strong></u>的<u><strong>非终结符</strong></u></p>
<h6 id="推导树"><a href="#推导树" class="headerlink" title="推导树"></a>推导树</h6><p>根据最左推导或最右推导得出</p>
<h5 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h5><p>要证明某个文法是二义的，需要使用这个文法自己创造一个句子(字符串)，再使用两种最左推导或者最右推导得出这个句子就说明此文法二义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/26/The-Summarize-of-Computer-Network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/The-Summarize-of-Computer-Network/" class="post-title-link" itemprop="url">The Summarize of Computer Network</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-26 09:50:47 / Modified: 09:51:20" itemprop="dateCreated datePublished" datetime="2021-07-26T09:50:47+08:00">2021-07-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1-Introduction"></a>1-Introduction</h2><h3 id="1-The-differences-between-Computer-Networks-and-Distributed-System"><a href="#1-The-differences-between-Computer-Networks-and-Distributed-System" class="headerlink" title="1.The differences between Computer Networks and Distributed System"></a><em>1.The differences between Computer Networks and Distributed System</em></h3><p>(1)Computer Network is a collection of autonomous computers interconnected by a single technology, but Distributed system is a collection of independent computers appears to its users as a single coherent(连贯的) system.</p>
<p>(2) A distributed system is a software system built on top of a network,gives it a high degree of cohesiveness and transparency. The difference of CN and DS lies with the software(especially the operating system)</p>
<p>(3)Distributed system example : the World Wide Web</p>
<h3 id="2-Transmission-technology"><a href="#2-Transmission-technology" class="headerlink" title="2.Transmission technology"></a><em>2.Transmission technology</em></h3><h3 id="1-Broadcast-networks"><a href="#1-Broadcast-networks" class="headerlink" title="(1)Broadcast networks:"></a>(1)Broadcast networks:</h3><p>the communication channel is shared by all the machines on the network,an address field within each packet specifies the <u>intend recipient.</u>(目的接收方)</p>
<p>i)Broadcasting :addressing a packet to all destinations</p>
<p>ii)Multicasting :support transmission to a subset of machines</p>
<p>iii)Two broadcast networks: Bus(line),Ring(circle)</p>
<h3 id="2-Point-to-point-links"><a href="#2-Point-to-point-links" class="headerlink" title="(2)Point-to-point links:,"></a>(2)Point-to-point links:,</h3><p>Also called unicasting. There re one or more immediate machines in the middle of channel , and we need to find a best length of different routes(路由)</p>
<h3 id="3-Classification-by-scale"><a href="#3-Classification-by-scale" class="headerlink" title="3.Classification by scale"></a><em>3.Classification by scale</em></h3><p>PAN-&gt;LAN-&gt;MAN-&gt;WAN-&gt;The Internet</p>
<h4 id="（1）LAN-Local-Area-Networks"><a href="#（1）LAN-Local-Area-Networks" class="headerlink" title="（1）LAN(Local Area Networks)"></a>（1）LAN(Local Area Networks)</h4><p>Each computer has a radio modem and an antenna that are used to communicated with other machines.</p>
<p>Including Channel allocation(信道冲突算法)</p>
<h4 id="（2）WAN"><a href="#（2）WAN" class="headerlink" title="（2）WAN"></a>（2）WAN</h4><p>Providing connections from a LAN to the Internet</p>
<p>Including Routing algorithm(路由算法)</p>
<h3 id="4-Protocol-Hierarchies"><a href="#4-Protocol-Hierarchies" class="headerlink" title="4. Protocol Hierarchies"></a>4. Protocol Hierarchies</h3><h4 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h4><p> Networks are organized as a stack of layers.</p>
<h4 id="Layer-5-Peers"><a href="#Layer-5-Peers" class="headerlink" title="Layer 5 Peers"></a>Layer 5 Peers</h4><p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\BC23C70BA0110A797A28C99B7D3B1096.png" alt=""></p>
<h3 id="5-QoS-Quality-of-service"><a href="#5-QoS-Quality-of-service" class="headerlink" title="5.QoS(Quality  of  service)"></a>5.QoS(Quality  of  service)</h3><p>Such as carrying live video,QoS is more about <u>timeliness of delivery</u>  </p>
<p>There are also other QoS such as <u>high throughput</u>,</p>
<h3 id="6-Connection-Oriented-and-Connectionless-Services"><a href="#6-Connection-Oriented-and-Connectionless-Services" class="headerlink" title="6. Connection-Oriented and Connectionless Services"></a>6. Connection-Oriented and Connectionless Services</h3><h4 id="1-Differences-between-Connection-Oriented-and-Connectionless-Services"><a href="#1-Differences-between-Connection-Oriented-and-Connectionless-Services" class="headerlink" title="(1) Differences between Connection-Oriented and Connectionless Services:"></a>(1) Differences between Connection-Oriented and Connectionless Services:</h4><p>(a) Connection-Oriented need to establish a connection at first.</p>
<p>(b) Using Connection-Oriented service, the bits will arrive in the order they were sent.</p>
<p>(c) For Connectionless Services, each message carries the full destination address.</p>
<h4 id="2-Connection-Oriented"><a href="#2-Connection-Oriented" class="headerlink" title="(2)Connection-Oriented"></a>(2)Connection-Oriented</h4><p>Most typical example: telephone system.</p>
<p>establish a connection—&gt;uses the connection—&gt;releases the connection, the bits will arrive in the order they were sent.</p>
<h4 id="3-Connectionless-Services"><a href="#3-Connectionless-Services" class="headerlink" title="(3)Connectionless Services"></a>(3)Connectionless Services</h4><p>(a)Each message carries the full destination address,and  is routed through the intermediate nodes inside the system independent of all the subsequent messages.</p>
<p>(b)Store-and-Forward switching. </p>
<p>The intermediate nodes receive a message in full before sending it on to the next node </p>
<p>(c)Cut-through switching.</p>
<p>Onward transmission of a message at a node starts before it is completely received by the node.</p>
<h4 id="4-Reliable-service"><a href="#4-Reliable-service" class="headerlink" title="(4)Reliable service"></a>(4)Reliable service</h4><p>The receiver acknowledge the receipt of each message so the sender is sure that it arrived.</p>
<p>Connection-Oriented and Connectionless Services can all be reliable and unreliable.</p>
<h5 id="a-Reliable-Connection-Oriented-service"><a href="#a-Reliable-Connection-Oriented-service" class="headerlink" title="(a)Reliable Connection-Oriented service:"></a>(a)Reliable Connection-Oriented service:</h5><p>typical example: file transfer </p>
<p>Reliable message stream: the message boundaries are preserved,Example: Sequence of pages</p>
<p>Reliable byte stream: simply a stream of bytes, no message boundary .Example: Movie download</p>
<h5 id="b-Unreliable-Connection-Oriented-service"><a href="#b-Unreliable-Connection-Oriented-service" class="headerlink" title="(b)Unreliable Connection-Oriented service:"></a>(b)Unreliable Connection-Oriented service:</h5><p>Example: Voice over IP.</p>
<h5 id="c-Connection-less-service"><a href="#c-Connection-less-service" class="headerlink" title="(c)Connection-less service:"></a>(c)Connection-less service:</h5><p>Unreliable datagram: example: Electronic junk mail</p>
<p>Acknowledged datagram: example: Text messaging</p>
<p>Request-reply: Database query</p>
<p>Unreliable Connection-less service also called <u>datagram service</u></p>
<h3 id="7-Protocol-Terminology-协议术语"><a href="#7-Protocol-Terminology-协议术语" class="headerlink" title="7.Protocol  Terminology(协议术语)"></a>7.Protocol  Terminology(协议术语)</h3><p>Service: Relates to an interface between two layers, with the lower layer being the service provider and the upper layer being the service user  </p>
<p>Protocol: A set of rules governing the format and meaning of the packets and messages that are exchanged by the peer.</p>
<h2 id="3-The-Data-Link-Layer"><a href="#3-The-Data-Link-Layer" class="headerlink" title="3-The  Data Link Layer"></a>3-The  Data Link Layer</h2><h3 id="3-1-Services-Provided-to-The-Network-Layer-Provide-service-interface-to-the-network-layer"><a href="#3-1-Services-Provided-to-The-Network-Layer-Provide-service-interface-to-the-network-layer" class="headerlink" title="3.1- Services Provided to The Network Layer        //    Provide  service interface to the network layer"></a>3.1- Services Provided to The Network Layer        //    Provide  service interface to the network layer</h3><h4 id="1-Diferent-services-："><a href="#1-Diferent-services-：" class="headerlink" title="1.Diferent services ："></a>1.Diferent services ：</h4><h4 id="1-Unacknowledged-connectionless-service"><a href="#1-Unacknowledged-connectionless-service" class="headerlink" title="(1)Unacknowledged connectionless service"></a>(1)Unacknowledged connectionless service</h4><p> most LAN uses this type of service in the data link layer</p>
<h4 id="2-Acknowledged-connectionless-service"><a href="#2-Acknowledged-connectionless-service" class="headerlink" title="(2)Acknowledged connectionless service"></a>(2)Acknowledged connectionless service</h4><p> this can be used over unreliable channels ,such as <u>wireless systems</u></p>
<h4 id="3-Acknowledged-connection-oriented-service"><a href="#3-Acknowledged-connection-oriented-service" class="headerlink" title="(3)Acknowledged connection-oriented service"></a>(3)Acknowledged connection-oriented service</h4><h3 id="3-2-Framing"><a href="#3-2-Framing" class="headerlink" title="3.2- Framing"></a>3.2- Framing</h3><h4 id="1-Character-Count"><a href="#1-Character-Count" class="headerlink" title="(1)Character Count"></a>(1)Character Count</h4><p>Use a field in the header to specify the number of characters in the frame.</p>
<p>disadvantage: if this field occur an error when transferring , this type of framing while be destroyed</p>
<p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\08A5AB1B36DE8EF87614A1AE4E1C30C6.png" alt="img"></p>
<h4 id="2-Byte-Stuffing"><a href="#2-Byte-Stuffing" class="headerlink" title="(2)Byte Stuffing"></a>(2)Byte Stuffing</h4><p>By using a flag byte stuffing,make special bytes at both start and end of each frame.</p>
<p>The end of the last frame is the start of the new frame.</p>
<p>Also ,if this flag byte is also used in the data frame,we need a ESC to make a difference. We also need a ESC when an ESC is used in the frame.</p>
<p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\2F445852B410600B02C826AAE96750AE.png" alt="img">  </p>
<h4 id="3-Bit-Stuffing"><a href="#3-Bit-Stuffing" class="headerlink" title="(3)Bit Stuffing"></a>(3)Bit Stuffing</h4><p>Can be understood like : byte stuffing’s byte is token place by a special bit: 01111110=0x7E</p>
<p>If this bit is used in data frame, we need to put in a ‘0’ after 5 coiled ‘1’,for example: 01111110—-&gt;011111010,so that detector won’t treat it as a flag bit.</p>
<p><strong>A disadvantage of Byte Stuffing and Bit Stuffing is that the length of a frame depends on the contents of the data it carries. If the data consists solely of flag bytes,as for Byte Stuffing, the length of frame has to become  200% of the data frame length ,as for Bit  Stuffing, the length of frame has to become  125% (1+1/8) of the data frame length.</strong></p>
<h4 id="4-Physical-Layer-Coding-Violations"><a href="#4-Physical-Layer-Coding-Violations" class="headerlink" title="(4)Physical Layer Coding Violations"></a>(4)Physical Layer Coding Violations</h4><p>Just use the redundant coding to represent different status.</p>
<h3 id="3-3-Error-Control"><a href="#3-3-Error-Control" class="headerlink" title="3.3- Error Control"></a>3.3- Error Control</h3><h4 id="1-Classifications-Lost-frames-and-Damaged-frames"><a href="#1-Classifications-Lost-frames-and-Damaged-frames" class="headerlink" title="(1)Classifications :Lost frames and Damaged frames"></a>(1)Classifications :Lost frames and Damaged frames</h4><h3 id="2-Single-bit-amp-Burst-Error"><a href="#2-Single-bit-amp-Burst-Error" class="headerlink" title="(2)Single-bit &amp; Burst Error"></a>(2)Single-bit &amp; Burst Error</h3><p>Need to notice: the length of burst error is the length from then first error to the last error</p>
<h3 id="3-Error-Detecting"><a href="#3-Error-Detecting" class="headerlink" title="(3)Error Detecting"></a>(3)Error Detecting</h3><h4 id="a-Parity"><a href="#a-Parity" class="headerlink" title="(a)Parity"></a>(a)Parity</h4><h4 id="b-Checksum"><a href="#b-Checksum" class="headerlink" title="(b)Checksum"></a>(b)Checksum</h4><h4 id="c-CRC-循环冗余检验码"><a href="#c-CRC-循环冗余检验码" class="headerlink" title="(c)CRC(循环冗余检验码)"></a>(c)CRC(循环冗余检验码)</h4><p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\E2E67B457FEF429E80D1CB541105FCA5.png" alt="img"></p>
<h4 id="CRC-can-detect-all-the-odd-number-error-all"><a href="#CRC-can-detect-all-the-odd-number-error-all" class="headerlink" title="CRC can detect all the odd number error,all"></a>CRC can detect all the odd number error,all</h4><h3 id="4-Error-Correcting"><a href="#4-Error-Correcting" class="headerlink" title="(4)Error Correcting"></a>(4)Error Correcting</h3><h4 id="a-Hamming-code"><a href="#a-Hamming-code" class="headerlink" title="(a)Hamming code"></a>(a)<strong>Hamming code</strong></h4><h4 id="Hamming-Distance-The-number-of-bit-positions-in-which-2-codewords-differ-Hamming-distance-of-a-valid-encoding-set-is-the-shortest-Hamming-distance-in-this-set"><a href="#Hamming-Distance-The-number-of-bit-positions-in-which-2-codewords-differ-Hamming-distance-of-a-valid-encoding-set-is-the-shortest-Hamming-distance-in-this-set" class="headerlink" title="Hamming Distance : The number of bit positions in which 2 codewords differ .Hamming distance of a valid encoding set is the shortest Hamming distance in this set."></a>Hamming Distance : The number of bit positions in which 2 codewords differ .Hamming distance of a valid encoding set is the shortest Hamming distance in this set.</h4><p>To detect d-bit errors, a code must have a minimum Hamming distance of at least d+1.</p>
<p>To correct d-bit errors, a code must have a minimum Hamming distance of at least 2d+1.</p>
<p>Hamming code can only correct single error.</p>
<p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\93CE0FBB27B28E91E1A87F9695D06484.png" alt="img"></p>
<h4 id="b-Binary-convolutional-codes"><a href="#b-Binary-convolutional-codes" class="headerlink" title="(b)Binary convolutional codes"></a>(b)Binary convolutional codes</h4><h4 id="c-Reed-Solomon-codes"><a href="#c-Reed-Solomon-codes" class="headerlink" title="(c)Reed-Solomon codes"></a>(c)Reed-Solomon codes</h4><h4 id="d-Low-Density-Parity-Check-codes"><a href="#d-Low-Density-Parity-Check-codes" class="headerlink" title="(d)Low-Density Parity Check codes"></a>(d)Low-Density Parity Check codes</h4><h3 id="Flow-Control-Regulating-data-flow-so-that-slow-receivers-won’t-be-swamped-by-fast-senders"><a href="#Flow-Control-Regulating-data-flow-so-that-slow-receivers-won’t-be-swamped-by-fast-senders" class="headerlink" title="Flow Control       //    Regulating data flow,so that slow receivers won’t be swamped by fast senders"></a>Flow Control       //    Regulating data flow,so that slow receivers won’t be swamped by fast senders</h3><h3 id="3-4-Elementary-Data-Link-Protocols"><a href="#3-4-Elementary-Data-Link-Protocols" class="headerlink" title="3.4- Elementary  Data  Link  Protocols"></a>3.4- Elementary  Data  Link  Protocols</h3><h3 id="3-5-Sliding-Windows-Protocols"><a href="#3-5-Sliding-Windows-Protocols" class="headerlink" title="3.5- Sliding  Windows  Protocols"></a>3.5- Sliding  Windows  Protocols</h3><h3 id="3-6-Example-Data-Link-Protocols"><a href="#3-6-Example-Data-Link-Protocols" class="headerlink" title="3.6-  Example Data  Link  Protocols"></a>3.6-  Example Data  Link  Protocols</h3><h2 id="4-The-MAC-Medium-Access-Control-Sublayer"><a href="#4-The-MAC-Medium-Access-Control-Sublayer" class="headerlink" title="4-The MAC(Medium Access Control) Sublayer"></a>4-The MAC(Medium Access Control) Sublayer</h2><p>Study field: broadcast channels,which also called multiaccess channels or random access channels</p>
<p>The protocols used to determine who goes next on a multiaccess channel belong to a subplayer of the data link layer called the <strong>MAC</strong> </p>
<h3 id="4-1-The-channel-allocation-problem"><a href="#4-1-The-channel-allocation-problem" class="headerlink" title="4.1-  The channel allocation problem"></a>4.1-  The channel allocation problem</h3><p><strong>Theme: How to allocate a single broadcast channel among competing users</strong></p>
<h4 id="The-poor-performance-of-static-FDM-queueing-theory"><a href="#The-poor-performance-of-static-FDM-queueing-theory" class="headerlink" title="The poor performance of static FDM: queueing theory"></a>The poor performance of static FDM: queueing theory</h4><p>a channel of capacity <strong><em>C</em></strong> bps;</p>
<p>mean time delay(时延): <strong><em>T</em></strong> ;</p>
<p>the frames arrive randomly with an average arrival rate : <strong><em>λ</em></strong> frames/sec ；</p>
<p>the average length of frames is <strong><em>1/μ</em></strong>；</p>
<p>the service rate(服务率) of the channel is <strong><em>μC</em></strong> frames/sec</p>
<p><strong>The standard queueing theory result: T = 1/(μC-λ)</strong></p>
<h4 id="Dynamic-channel-allocation"><a href="#Dynamic-channel-allocation" class="headerlink" title="Dynamic channel allocation"></a>Dynamic channel allocation</h4><h5 id="The-assumption-bases-on-5-keys"><a href="#The-assumption-bases-on-5-keys" class="headerlink" title="The assumption bases on 5 keys:"></a>The assumption bases on 5 keys:</h5><p>Independent traffic</p>
<p>Single Channel</p>
<p>Observable Collision</p>
<p>Continuous or Slotted Time</p>
<p>Carrier Sense or No Carrier Sense</p>
<h3 id="4-2-Multiple-Access-Protocols"><a href="#4-2-Multiple-Access-Protocols" class="headerlink" title="4.2- Multiple Access Protocols"></a>4.2- Multiple Access Protocols</h3><h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><p>一个帧成功发送的条件：设发送一帧所需时间为T，且帧长固定，必须在发送该帧前后各一段时间T内(共2T时间间隔)没有其他帧发送。</p>
<h5 id="Pure-ALOHA"><a href="#Pure-ALOHA" class="headerlink" title="Pure ALOHA"></a>Pure ALOHA</h5><p>Time is <strong><em>continuous</em></strong>. And if a station plan to send a frame,it will be <strong><em>No Carrier Sense</em></strong> </p>
<p>If the frame is destroyed, the sender must wait a random amount of time and sends it again.</p>
<p>We have made the frames all the same length so that the throughput(吞吐量) if ALOHA system is maximized</p>
<p>The <strong><em>efficiency</em></strong> of an ALOHA channel:</p>
<p>The throughput <strong>S</strong> = load <strong>G</strong> <em> probability of a transmission succeeding <em>*P~0~</em></em>,  </p>
<p>During a frame time , the probability that <strong>k</strong> frames are generated is :<strong>P[K]=G^K^e^-G^/k!</strong></p>
<p>So: during a given frame time, G frames are expected ,and P(k=0)=e^-G^                </p>
<p>during two frame times, the average number of generated frames is 2G and P(k=0)=e^-2G^</p>
<p>because of <strong>S=G<em>P~0~, S=G</em>e^-2G^</strong></p>
<p>The maximum throughput occurs when G=0.5，S=0.5e=0.184</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\14372\Desktop\1.png" alt="1"></h5><p>每终端每秒钟发送长度(信息到达率)λ：256/60</p>
<p>最多终端个数：<strong><em>N=C</em>S/λ*</strong>           S~max~=0.184</p>
<p>∴N~max~=2400*0.184/(256/60)=103.5</p>
<h5 id="Slotted-ALOHA"><a href="#Slotted-ALOHA" class="headerlink" title="Slotted ALOHA"></a>Slotted ALOHA</h5><p>A station is not permitted to send whenever the user types a line. Instead, it is required to wait  for the beginning of</p>
<p>the next slot.</p>
<p>The vulnerable period(冲突危险周期) becomes half of before. </p>
<p>During a frame time , the probability that <strong>k</strong> frames are generated is <strong><em>P[K]=G^K^e^-G^/k!</em></strong></p>
<p>and P(k=0)=e^-G^</p>
<p>∴throughput S=Ge^-G^ </p>
<p>The maximum throughput occurs when G=1, S=1/e.  The best we can hope for using slotted ALOHA is 37% of the slot empty, 37% success , 26% collisions. </p>
<p>TEST: the probability of avoiding a collision P(k=0)=e^-G^</p>
<p>​            the probability of collision is 1-P(k=0)=1-e^-G^</p>
<p>​            the probability of a transmission requires <strong>n</strong> attempts is <strong><em>P~n~=e^-G^（1-e^-G^）^k-1^</em></strong> </p>
<p>​            sum all above, the expected times of transmission <strong>E=e^G^</strong></p>
<h4 id="Carrier-Sense-Multiple-Access-Protocols-CSMA"><a href="#Carrier-Sense-Multiple-Access-Protocols-CSMA" class="headerlink" title="Carrier Sense Multiple  Access Protocols (CSMA)"></a>Carrier Sense Multiple  Access Protocols (CSMA)</h4><p>Station listens for a carrier before  Sending</p>
<p>If a collision occurs, waits for a random amount  of time and start all over again.</p>
<p><strong>1-persistent CSMA</strong></p>
<p>If the channel is busy, waits until it becomes  idle, then transmits frame immediately.</p>
<p>depends on 1、the number of frames that fit on the channel</p>
<p>​                    2、the bandwidth_delay product of the channel</p>
<p>Low delay when low load </p>
<p>Low throughput when high load</p>
<p><strong>Nonpersistent CSMA</strong></p>
<p>if the channel is busy, waits for a random amount  of time and sense channel again</p>
<p>longer delay than 1-persistent CSMA</p>
<p><strong>p-persistent CSMA</strong></p>
<p>applies to slotted channels</p>
<p>If the channel is busy, waits to the next slot </p>
<p>If idle, transmits frame with probability of p, with  a probability of q=1-p it defers to the next slot </p>
<p>Repeated until either the frame has been  transmitted or another station has begun  transmitting </p>
<p>If there had been a collision, waits a random time and starts again</p>
<p><strong>CSMA with Collision Detection    (CSMA/CD)</strong></p>
<p>The stations quickly detect the collision and abruptly stop transmitting as soon as it  detects a collision.</p>
<p>CSMA/CD with a single channel is  inherently <strong>a half-duplex system</strong>(半双工系统)</p>
<p><img src="C:\Users\14372\Desktop\2.png" alt="2" style="zoom:60%;" /></p>
<p>If the time for a signal between two stations is t, a station cannot be sure that it has seized the channel until it has transmitted for 2t without hearing a collision,</p>
<p>So that this CSMA/CD can be seen as a slotted ALOHA with a slot width of 2t</p>
<h5 id="Collision-Free-Protocol"><a href="#Collision-Free-Protocol" class="headerlink" title="Collision-Free Protocol"></a>Collision-Free Protocol</h5><h6 id="A-Bit-Map-Protocol"><a href="#A-Bit-Map-Protocol" class="headerlink" title="A Bit_Map Protocol"></a>A Bit_Map Protocol</h6><p>Each contention period consists of N slots (bits),  with each station use one slot</p>
<p>If station have frames to send, it reserve it by fill  ‘1’ in its slot, after all N slots have passed by and been recognized, they begin transmitting frames in order </p>
<p><img src="C:\Users\14372\Desktop\3.png" alt="3" style="zoom:60%;"/></p>
<p>reservation protocols: reserve channel ownership in advance and prevent collisions</p>
<p>N station, contention time is <em>N</em> </p>
<p>One data frame is d bits, so time is <em>d</em></p>
<p>Low load: Efficiency=d/(d+N)</p>
<p>High load: Efficiency=d/(d+1)</p>
<h6 id="Binary-Countdown-二进制倒计数"><a href="#Binary-Countdown-二进制倒计数" class="headerlink" title="Binary Countdown(二进制倒计数)"></a>Binary Countdown(二进制倒计数)</h6><p>如果一个站想要使用信道，他就用二进制位串的形式广播自己的地址</p>
<p>仲裁规则：从最左边开始，一个站只要看到自己地址位中的0被改为1，就必须放弃竞争。n个站想要一同发送数据时，从最左边开始一位一位的进行or操作，知道只剩一个站的地址。</p>
<p>得到结果：高序站的优先级高</p>
<p>这种方法信道利用率(channel efficiency)=<em>d/(d+log~2~N)</em></p>
<h4 id="无线局域网协议"><a href="#无线局域网协议" class="headerlink" title="无线局域网协议"></a>无线局域网协议</h4><p>隐藏终端问题(hidden station problem):由于竞争者离得太远而导致站无法检测到潜在的竞争者</p>
<p>暴露终端问题(exposed station problem):开始传输之前，站不能知道接收方附近的无线电活动是否有影响。</p>
<h5 id="MACA-冲突避免多路访问"><a href="#MACA-冲突避免多路访问" class="headerlink" title="MACA(冲突避免多路访问)"></a>MACA(冲突避免多路访问)</h5><p>C———A——-&gt;B———D</p>
<p>A 首先给 B 发送一个 RTS(Request To Send)帧，B 用一个 CTS(Clear to Send)作为应答。A 在收到了 CTS 帧之后便开始传输，C收到A的RTS，收不到B的CTS，所以C自由活动除了对A。D收到B的CTS但没收到RTS，D就安静直到CTS要求的时间结束。</p>
<h3 id="4-3-Ethernet-以太网"><a href="#4-3-Ethernet-以太网" class="headerlink" title="4.3-Ethernet(以太网)"></a>4.3-Ethernet(以太网)</h3><p>中继器(repeater)：能接收，放大并在两个方向上重发信号</p>
<h4 id="经典以太网MAC子层协议-Classic-Ethernet-MAC-sub-protocol"><a href="#经典以太网MAC子层协议-Classic-Ethernet-MAC-sub-protocol" class="headerlink" title="经典以太网MAC子层协议(Classic Ethernet MAC sub protocol)"></a>经典以太网MAC子层协议(Classic Ethernet MAC sub protocol)</h4><p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210615214036395.png" alt="image-20210615214036395" style="zoom: 40%;" />(a)以太网  （b) IEEE 802.3</p>
<p>Preamble:前导码，<strong>8</strong>个字节，前7个字节均为10101010，最后一个：10101011(802.3的帧起始定界符SOF)</p>
<p>Destination address:目标地址 ，<strong>6</strong>个字节</p>
<p>目标地址第一位为0：普通地址 </p>
<p>第一位为1：表示组地址，是一个组播</p>
<p>目标地址段全为1：广播</p>
<p>Source address:源地址 ，<strong>6</strong>个字节</p>
<p>以太网:Type:类型,<strong>2</strong>字节,告诉接收方阵内包含什么数据包.  0x0800==&gt;ipv4</p>
<p>802.3:Length类型,不定长度</p>
<p>Data:数据段:最多<strong>1500</strong>字节</p>
<p>以太网要求从目标地址算到校验和,这个有效帧必须至少<strong>64</strong>字节(即数据段至少为<strong>46</strong>字节),小于64则使用<strong>Pad</strong>(填充)来加入达到最少长度.限制最小帧为了防止过于短的帧还未到达,传送已经结束 .所以所有帧必须至少需要2t(传播时延)时间才能完成传送.</p>
<p>Checksum:校验和:最少<strong>4</strong>字节,32位.</p>
<p>数据字段的长度在 46 ~ 1500 字节之间。 有效的 MAC 帧长度为 64 ~ 1518 字节之间</p>
<p>以太网中使用的成帧方法是 <strong>物理层编码违例法</strong></p>
<h4 id="二进制指数后退的CSMA-CA-Binary-exponential-backoff"><a href="#二进制指数后退的CSMA-CA-Binary-exponential-backoff" class="headerlink" title="二进制指数后退的CSMA/CA(Binary exponential  backoff)"></a>二进制指数后退的CSMA/CA(Binary exponential  backoff)</h4><p>为达到以太网所允许的最长路径，时槽的长度被设置为 512 位时间，或 51.2 us。在第 i 次冲突后，在 0-2 i -1 之间随机选择一个数， 然后等待这么多个时槽。到达 10 次冲突之后，固定在最大值 1023 上</p>
<h4 id="以太网信道利用率"><a href="#以太网信道利用率" class="headerlink" title="以太网信道利用率"></a>以太网信道利用率</h4><p>针对每个帧e个竞争时间槽：</p>
<p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210617150858434.png" alt="image-20210617150858434" style="zoom:50%;" /></p>
<h4 id="交换机（switch）"><a href="#交换机（switch）" class="headerlink" title="交换机（switch）"></a>交换机（switch）</h4><p>完全避免冲突，一个站使用一个冲突域，比集线器提升性能</p>
<h4 id="快速以太网：802-3u"><a href="#快速以太网：802-3u" class="headerlink" title="快速以太网：802.3u"></a>快速以太网：802.3u</h4><p>保留原来帧格式，接口和过程规则，只是将比特时间从100ns降低到10ns。技术上照搬经典以太网，只是将电缆最大长度降低到十分之一</p>
<h4 id="千兆以太网："><a href="#千兆以太网：" class="headerlink" title="千兆以太网："></a>千兆以太网：</h4><p>全双工+半双工</p>
<p>半双工：载波扩充(carrier extension)</p>
<p>​            在普通帧后面加填充位到512字节，效率低</p>
<p>​              帧突发(frame bursting) </p>
<p>​            将多个待发送帧级联在一起，一次发送出去，不到512字节 再填充</p>
<p>巨型帧(Jumbo frame)</p>
<h4 id="万兆以太网："><a href="#万兆以太网：" class="headerlink" title="万兆以太网："></a>万兆以太网：</h4><p>只支持全双工</p>
<p>中继器：对网段上衰减的信号进行放大整形或再生，用于实现网络物理层的连接。只起扩展网段距离的作用，使用中继器互连的网 络在逻辑上仍属于同一网络，是物理层的设备。在经典以太网中，以太网允许使用 4 个中继器，最大长度从 500 米扩展到 2500 米。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。  </p>
<p>网桥：在不同或者相同的局域网之间存储和转发帧，ᨀ供数据链路层上协议转换功能。网桥的功能是通过过滤和转发实现的。常见 的网桥有透明网桥和源路由选择网桥 </p>
<p>路由器：作用于网络层，在不同的网络间存储和转发分组，供网络层上的协议转换。 </p>
<p>网关：对传输层和应用层协议进行协议转换的网间连接器，又称为协议转换器。网关一般有两种：传输层网关和应用层网关，分别 工作于传输层和应用层</p>
<h3 id="4-4-802-11"><a href="#4-4-802-11" class="headerlink" title="4.4-802.11"></a>4.4-802.11</h3><h4 id="带有冲突避免的CSMA：CSMA-CA"><a href="#带有冲突避免的CSMA：CSMA-CA" class="headerlink" title="带有冲突避免的CSMA：CSMA/CA"></a>带有冲突避免的CSMA：CSMA/CA</h4><p>发送前先检测，检测到有冲突 ，在后退时间槽数选择范围内：0~15，选择一个时间槽进行等待，倒数空闲时间槽，有帧发送则暂停倒数，直到倒数为0</p>
<h3 id="Virtual-LAN-VLAN"><a href="#Virtual-LAN-VLAN" class="headerlink" title="Virtual LAN(VLAN)"></a>Virtual LAN(VLAN)</h3><p>实际使用VLAN字段的是网桥和交换机，为了使用VLAN，网桥必须能感知VLAN,因为存在一些计算机和交换机无法感知VLAN，因此第一个VLAN感知的网桥在帧上添加一个VLAN字段，路径上最后一个网桥再将其删除</p>
<h2 id="5-Network"><a href="#5-Network" class="headerlink" title="5-Network"></a>5-Network</h2><p>数据链路层的目标是将帧从线的一端传送到另一端。 网络层是处理端到端数据传输的最低层</p>
<h3 id="5-1-Network-Layer-Design-Issues"><a href="#5-1-Network-Layer-Design-Issues" class="headerlink" title="5.1-Network Layer  Design Issues"></a>5.1-Network Layer  Design Issues</h3><h4 id="存储-转发数据包交换："><a href="#存储-转发数据包交换：" class="headerlink" title="存储-转发数据包交换："></a>存储-转发数据包交换：</h4><p>要发送一个数据包，就将其传输给最近的路由器，路由器的链路层对其进行校验和验证，就先将它存储起来，然后转发给下一个路由器直到主机</p>
<h4 id="数据包和虚电路"><a href="#数据包和虚电路" class="headerlink" title="数据包和虚电路"></a>数据包和虚电路</h4><p>无连接服务，每个数据包独立路由。这样的数据包常称为<strong>数据报</strong>，对应数据包网络</p>
<p>面向连接服务，先建立连接 。这个连接称为<strong>虚电路</strong>，对应虚电路网络 </p>
<p>数据包的路由过程：</p>
<p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210617172830374.png" alt="image-20210617172830374" style="zoom:50%;" /></p>
<p>每个表项由两部分组成：<em>目标地址</em> 和通往目标地址所使用的<em>出境线路</em></p>
<p>虚电路网络路由：</p>
<p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210617191032341.png" alt="image-20210617191032341" style="zoom:50%;" /></p>
<p>H1和H3的连接标识符一定为1，是他们唯一的连接。</p>
<h3 id="5-2-Routing-Algorithms"><a href="#5-2-Routing-Algorithms" class="headerlink" title="5.2-Routing Algorithms"></a>5.2-Routing Algorithms</h3><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>每有一个数据包到达就对他进行处理，在路由表中查找该数据包对应的出境线路</p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>负责生成和更新路由表</p>
<p>数据报：每到一个数据包都要重新选择路径</p>
<p>虚电路：建立一条新的虚电路需要路由</p>
<h4 id="最优化原则"><a href="#最优化原则" class="headerlink" title="最优化原则"></a>最优化原则</h4><p>从所有的元到一个指定目标的最优路径的集合构成一棵以<strong>目标节点</strong>为根的树，这棵树称为汇集树(sink tree)</p>
<p>汇集树不唯一，把所有可能的路径汇聚在一起，树就变成了有向无环图(DAG)</p>
<h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><p>跳数测量</p>
<p>物理距离测量</p>
<p>Dijkstra算法</p>
<h4 id="泛洪算法"><a href="#泛洪算法" class="headerlink" title="泛洪算法"></a>泛洪算法</h4><p>将每一个入境数据包发送到除了该数据到达的那条线以外的所有线。</p>
<p>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</p>
<p>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 </p>
<p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p>
<h4 id="距离矢量路由-distance-vector-routing"><a href="#距离矢量路由-distance-vector-routing" class="headerlink" title="距离矢量路由(distance vector routing)"></a>距离矢量路由(distance vector routing)</h4><p>不需要知道拓扑</p>
<p>每个路由器都有一个表，列出已知的到每个目标的最佳距离。每个邻居路由器会互相交换表 ，最终每个路由器都明白到每个目的地最优解。所以全网路由器的拓扑数据库是一致的，有错误也是一致的</p>
<p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\283D9772F65A47D381974C898302EE5C.png" alt="img" style="zoom:40%;" /></p>
<h5 id="收敛-convergence"><a href="#收敛-convergence" class="headerlink" title="收敛(convergence)"></a>收敛(convergence)</h5><p>整个网络最佳路径的寻找过程称为收敛</p>
<h5 id="距离矢量路由特点："><a href="#距离矢量路由特点：" class="headerlink" title="距离矢量路由特点："></a>距离矢量路由特点：</h5><p> 1.分布的 每个节点接收来自与其直接邻接节点的路由信息，并执行路由计算，将计算结果回传给直接邻接的节点</p>
<p>  2.迭代的 计算过程循环进行，直到相邻节点没有可交换的路由信息为止</p>
<p>  3.异步的 并不要求所有节点相互锁步操作</p>
<p>4.会产生2个问题，无限计数和路由环路问题。</p>
<h4 id="链路状态路由-link-state-routing"><a href="#链路状态路由-link-state-routing" class="headerlink" title="链路状态路由(link  state routing)"></a>链路状态路由(link  state routing)</h4><p>需要知道拓扑</p>
<h5 id="发现邻居"><a href="#发现邻居" class="headerlink" title="发现邻居"></a>发现邻居</h5><p>路由器启动，向每条p2p链路上发送hello包 ，链路另一方会向它回复自己的名字；或者向broadcast网络广播hello接受回复.</p>
<p>简化LAN使用人造节点N代表广播LAN</p>
<h5 id="设置链路成本"><a href="#设置链路成本" class="headerlink" title="设置链路成本"></a>设置链路成本</h5><p>寻找最短路径，需要每条链路度量的成本或距离；链路延迟也可以当作成本；</p>
<p>成本与链接的线路带宽成反比，所以带宽越大，成本越低，越容易被选中；</p>
<h5 id="构造链路状态包"><a href="#构造链路状态包" class="headerlink" title="构造链路状态包"></a>构造链路状态包</h5><p>构建一个包含所有这些信息的数据包 ；</p>
<p>数据包内容：</p>
<p>发送方的标识符，序号，年龄，邻居列表，到这个邻居的延迟；</p>
<p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210617200142849.png" alt="image-20210617200142849" style="zoom:44%;" /></p>
<p>可以周期性的或者发生事情的时候创建数据表；</p>
<h5 id="分发链路状态包"><a href="#分发链路状态包" class="headerlink" title="分发链路状态包"></a>分发链路状态包</h5><p>使用的是可靠的扩散法 </p>
<p>为了控制泛洪，每个分组含一个序号，每次发送新分组时加一；</p>
<p>路由器记录信息对（源路由器，序号）</p>
<p>如果序列号回转了，则可能会产生混淆。解决办法：使用 32 位序号； </p>
<p>若路由器崩溃后，序号重置；或者序号出错； 解决方法：增加年龄（age）域，每秒钟年龄减 1，为零则丢弃；</p>
<p>链路状态包到达后，延迟一段时间，并与其它已到达的来自同一路由器的链路状态包比较序号，丢弃重复包，保留新包； </p>
<p>链路状态包需要应答；</p>
<h5 id="计算新路由"><a href="#计算新路由" class="headerlink" title="计算新路由"></a>计算新路由</h5><p>每个路由器都获得了自己的路由拓扑图 </p>
<p>根据 Dijkstra 算法计算最短路径; </p>
<p>生成自己的路由表</p>
<h4 id="分层路由"><a href="#分层路由" class="headerlink" title="分层路由"></a>分层路由</h4><p>应该分多少层？</p>
<p>考虑：1个由720个路由器构成的子网：720个路由表项</p>
<p>​                    24个区域，30个路由器：30个本地路由表项+（24-1）个远程表项=53个路由表项</p>
<p>​        8个族，9个区域，10个路由器：10个本地路由表项+（9-1）个其他区域表项+（8-1）个远程表项=25个路由表项</p>
<p>N个路由器，最优：lnN层</p>
<h5 id="链路状态算法特点："><a href="#链路状态算法特点：" class="headerlink" title="链路状态算法特点："></a>链路状态算法特点：</h5><p>每个节点都有完整地网络拓扑图，也就是完整的链路信息（距离矢量法只知道和相邻路由的）</p>
<h4 id="距离矢量和链路状态的区别："><a href="#距离矢量和链路状态的区别：" class="headerlink" title="距离矢量和链路状态的区别："></a>距离矢量和链路状态的区别：</h4><h5 id="距离矢量"><a href="#距离矢量" class="headerlink" title="距离矢量:"></a>距离矢量:</h5><p>运行距离矢量路由协议的路由器,会将所有它知道的路由信息与邻居共享,但是只与直连邻居共享！</p>
<p> 由于每台路由器都必须在将从邻居学到的路由转发给其它路由器之前，运行路由算法，所以网络的规模越大，其收敛速度越慢。</p>
<p>距离矢量路由协议，更新的是“路由条目”！一条重要的链路如果发生变化，意味着需通告多条涉及到的路由条目！</p>
<p>发送周期性更新、完整路由表更新。</p>
<h5 id="链路状态"><a href="#链路状态" class="headerlink" title="链路状态:"></a>链路状态:</h5><p>运行链路状态路由协议的路由器,只将它所直连的链路状态与邻居共享,这个邻居是指一个域内(domain),或一个区域内(area)的所有路由器！</p>
<p>路由器在转发链路状态包时（描述链路状态、拓扑变化的包），没必要首先进行路由运算，再给邻居进行发送，从而加快了网络的收敛速度。</p>
<p> 链路状态路由协议，更新的是“拓扑”！每台路由器上都有完全相同的拓扑，一条重要链路的变化，不必再发送所有被波及的路由条目，只需发送一条链路通告，告知其它路由器本链路发生故障即可。</p>
<p>更新是非周期性的，部分的。</p>
<h3 id="5-3-拥塞控制-Congestion-control"><a href="#5-3-拥塞控制-Congestion-control" class="headerlink" title="5.3-拥塞控制(Congestion control )"></a>5.3-拥塞控制(Congestion control )</h3><p>负载的增加，突发流量与缓冲队列(太长和太短）都会造成拥塞</p>
<h4 id="流量感知路由"><a href="#流量感知路由" class="headerlink" title="流量感知路由"></a>流量感知路由</h4><h4 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h4><p>漏桶和令牌桶</p>
<h4 id="流量调节"><a href="#流量调节" class="headerlink" title="流量调节"></a>流量调节</h4><h5 id="路由器要确定何时接近拥塞"><a href="#路由器要确定何时接近拥塞" class="headerlink" title="路由器要确定何时接近拥塞"></a>路由器要确定何时接近拥塞</h5><p>EWMA:指数加权移动平均</p>
<p>路由器内部的排队延迟直接捕获了数据包经历过的任何拥塞</p>
<p>当有一个突发流量产生挤压时会跳跃。</p>
<p>为了维持良好的排队延迟估计d，假设顺势队列长度的样值为s，可以定期生成d，并按如下方式更新：</p>
<p>d~new~=αd~old~+(1+α)s</p>
<p>当d上升到某个阈值，路由器要注意拥塞 </p>
<h5 id="路由器要及时反馈信息给造成拥塞的发送方"><a href="#路由器要及时反馈信息给造成拥塞的发送方" class="headerlink" title="路由器要及时反馈信息给造成拥塞的发送方"></a>路由器要及时反馈信息给造成拥塞的发送方</h5><h5 id="不同反馈机制-都是已经发生拥塞，缓冲区溢出-："><a href="#不同反馈机制-都是已经发生拥塞，缓冲区溢出-：" class="headerlink" title="不同反馈机制(都是已经发生拥塞，缓冲区溢出)："></a>不同反馈机制(都是已经发生拥塞，缓冲区溢出)：</h5><p>抑制(choke packets)：</p>
<p>给发送方的抑制包中的目标地址取自某个被拥塞的数据包，告知发送方慢点</p>
<p>显式拥塞控制(ECN)：隐式地拥塞通知就是丢包 </p>
<p>路由器在它转发的任何一个数据包打上标记发出拥塞信号，发送应答包的时候告知发送方慢点</p>
<p>逐条后压：</p>
<p>让抑制包在每一条都发挥作用</p>
<h4 id="负载脱落-Load-shedding"><a href="#负载脱落-Load-shedding" class="headerlink" title="负载脱落(Load shedding)"></a>负载脱落(Load shedding)</h4><h5 id="随机早期检测-RED"><a href="#随机早期检测-RED" class="headerlink" title="随机早期检测:RED"></a>随机早期检测:RED</h5><p>当某条链路上的平均队列长度超过阈值，该链路被认为<strong>即将</strong>拥塞，所以随即丢弃一部分数据包，引起发送方注意，是隐式通知。</p>
<h3 id="5-4-QoS"><a href="#5-4-QoS" class="headerlink" title="5.4-QoS"></a>5.4-QoS</h3><p>四个因素：</p>
<p>可靠性，延迟，抖动，带宽</p>
<h4 id="漏桶算法：leaky-bucket-algorithm"><a href="#漏桶算法：leaky-bucket-algorithm" class="headerlink" title="漏桶算法：leaky bucket algorithm"></a>漏桶算法：leaky bucket algorithm</h4><p>限制了一个流的长期速率，但允许其短期突发某个最高调节长度。大量的突发数据将被一个漏桶流量整形器进行平滑处理。</p>
<h5 id="计算最大突发长度-Length-of-Maximum-Rate-Burst-："><a href="#计算最大突发长度-Length-of-Maximum-Rate-Burst-：" class="headerlink" title="计算最大突发长度(Length of Maximum Rate Burst)："></a>计算最大突发长度(Length of Maximum Rate Burst)：</h5><p>突发长度是一个时间长度，以秒为单位来计算 </p>
<p>burst length S ：突发长度</p>
<p>sec token bucket capacity B ：令牌桶容量</p>
<p>bytes token arrival rate R bytes/sec ：令牌到达率</p>
<p>maximum output rate M bytes/sec ：最大输出率</p>
<p>B + RS = MS </p>
<p>S = B/(M - R ) </p>
<p>时间=数量/实际输出速率=容量/(最大输出率-令牌到达率)</p>
<h4 id="数据包调度算法-packet-scheduling-algorithms"><a href="#数据包调度算法-packet-scheduling-algorithms" class="headerlink" title="数据包调度算法(packet scheduling algorithms)"></a>数据包调度算法(packet scheduling algorithms)</h4><p>FIFO=FCFS</p>
<p>先入先出，队列算法</p>
<p><strong>尾丢包</strong>：在队列满时丢弃新到的数据包</p>
<p>RED:队列快满时随即丢数据包</p>
<h5 id="公平队列（fair-queueing）"><a href="#公平队列（fair-queueing）" class="headerlink" title="公平队列（fair queueing）"></a>公平队列（fair queueing）</h5><p>主要问题：每次取一个数据包，对于小数据包的主机提供的带宽更少</p>
<h5 id="加权公平队列"><a href="#加权公平队列" class="headerlink" title="加权公平队列"></a>加权公平队列</h5><p>设每一轮的字节数是一个流的权重W</p>
<p>F~i~=max(A~i~,F~i-1~)+L~i~/W：A~i~是第i个包到达时间，F~i-1~是上一个包完成的时间，L~i~是数据包i的长度</p>
<p>max(A~i~,F~i-1~):指的是就算一个数据包早到了，也要等上一个传完才开始传这个</p>
<h3 id="5-5-Internet-working⭐⭐"><a href="#5-5-Internet-working⭐⭐" class="headerlink" title="5.5-Internet working⭐⭐"></a>5.5-Internet working⭐⭐</h3><h5 id="路由器和交换机-网桥的本质区别："><a href="#路由器和交换机-网桥的本质区别：" class="headerlink" title="路由器和交换机/网桥的本质区别："></a>路由器和交换机/网桥的本质区别：</h5><p>在路由器上，数据包被从帧中提取出来，数据包中的网络地址被用来决定把它转发到哪里。而在交换机上，整个帧都是根据它的MAC地址发送的，不会提出数据包。</p>
<h5 id="隧道（tunneling）"><a href="#隧道（tunneling）" class="headerlink" title="隧道（tunneling）"></a>隧道（tunneling）</h5><p>当源主机和目标主机所在网络的类型完全相同时，如IPv6-IPv4-IPv6，路由器将IPv6放在一个IPv4的数据包内，包裹着这个数据包到另一头。</p>
<h4 id="将分段组成原始数据包（Fragmentation）"><a href="#将分段组成原始数据包（Fragmentation）" class="headerlink" title="将分段组成原始数据包（Fragmentation）"></a>将分段组成原始数据包（Fragmentation）</h4><h5 id="透明的"><a href="#透明的" class="headerlink" title="透明的"></a>透明的</h5><p>某个路由器进行分段那么下一个路由就马上进行重组。所以后续的网络不会感到有分段</p>
<h5 id="非透明的"><a href="#非透明的" class="headerlink" title="非透明的"></a>非透明的</h5><p>一旦被分组，每个分组被当成原始数据包传送，直到目标主机才重组</p>
<p>那么分段必须有各自的数据包头。</p>
<p>数据包头包括：<strong>数据包序号</strong>（每个数据包都携带）、一个数据包内的<strong>绝对字节偏移量</strong>、一个指明此分段能否到达分段前数据包末尾的<strong>标志位</strong>。</p>
<p>这样除了增加开销，每一段的丢失都会造成整个数据包丢失</p>
<h4 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h4><p>先不分段，发送，到一个路由器时，数据包太大发不过去，就给源端一个报错数据包，并丢弃这个包。远端收到就把这个数据包分段重发。不断重复</p>
<h3 id="5-6-The-Network-Layer-in-the-Internet"><a href="#5-6-The-Network-Layer-in-the-Internet" class="headerlink" title="5.6-The Network Layer  in the Internet"></a>5.6-The Network Layer  in the Internet</h3><h4 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h4><p>每个IP数据报包括：头，正文（有效净负荷）</p>
<p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\F2C8001DA2BDC550BB908C22DE14D173.png" alt="img" style="zoom:50%;" /></p>
<h5 id="IPv4的分类编址："><a href="#IPv4的分类编址：" class="headerlink" title="IPv4的分类编址："></a>IPv4的分类编址：</h5><p>A：0打头，8位网络号+24位主机号       </p>
<p>最大网络号127为回环地址，不可指派</p>
<p>地址范围：0-127，可指派范围：2^8-1^-2=126</p>
<p>每个网络号中可分配的IP地址数量：2^24^-2</p>
<p>B：10打头，16位网络号+16位主机号</p>
<p>地址范围：128.0-191.255，可指派范围：2^16-2^=16384</p>
<p>每个网络号中可分配的IP地址数量：2^16^-2</p>
<p>C：110打头，24位网络号+8位主机号</p>
<p>地址范围：192.0.0-223.255，可指派范围：2^24-3^</p>
<p>每个网络号中可分配的IP地址数量：2^8^-2</p>
<p>源IP地址和目的IP地址：</p>
<p>以127开头且后面不是全0和全1得IP地址可以做源地址和目的地址</p>
<p>主机号全1的广播地址：只能做目的地址 </p>
<p>网络号全0：只能做源地址</p>
<h5 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h5><p>假设有m位主机号</p>
<p>借用了n位主机号就有2^n^个子网数量</p>
<p>每个子网可分配的地址数量=2^m-n^-2个</p>
<p>主机IP地址可以在某个子网中。只需要查看借走n位那n位以后全部取0得到的IP地址就是该主机所在子网的网络地址</p>
<p>n位以后全部取1得到的IP地址就是该主机所在子网的广播地址</p>
<h5 id="无分类编址的IPv4地址：CIDR"><a href="#无分类编址的IPv4地址：CIDR" class="headerlink" title="无分类编址的IPv4地址：CIDR"></a>无分类编址的IPv4地址：CIDR</h5><p>消除了ABC类地址以及划分子网的概念</p>
<p>引进了 网络前缀</p>
<p>128.14.24.7/21</p>
<p>这个斜线后面的数字就是网络前缀所占的比特数量</p>
<p>32-21=11就是主机号的比特数</p>
<p>注意可接收地址、可分配 的主机个数不等于主机号的数量</p>
<p>若知道CIDR中某个地址就可以知道：地址块最小地址，地址块最大地址，地址块地址数量，地址块聚合某类地址的数量，地址掩码=子网掩码</p>
<p><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\3694006375C37C812197A3428958AC7D.png" alt="img" style="zoom:40%;" /></p>
<h5 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h5><p>寻找目的网络地址的共同前缀，假设有n个比特，则网络前缀就是多少，剩余的比特全部取0，整个32位写成十进制放在网络前缀前面，就形成了<strong>聚合地址块</strong>。</p>
<p>网络前缀越长，地址块越小，路由越具体 。</p>
<p>路由器转发分组会选择路由中网络前缀最长的部分。—最长前缀匹配</p>
<h5 id="IPv4的应用规划"><a href="#IPv4的应用规划" class="headerlink" title="IPv4的应用规划"></a>IPv4的应用规划</h5><h6 id="定长的子网掩码：FLSM"><a href="#定长的子网掩码：FLSM" class="headerlink" title="定长的子网掩码：FLSM"></a>定长的子网掩码：FLSM</h6><p>每个子网分配的IP地址相同，造成了浪费</p>
<h6 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\D3D739B517310B6D6A84C1BFCB13F384.png" alt="img" style="zoom:40%;" /></h6><p>要分配给5个子网，所以要分配2^3^=8个子网，得借3个主机号</p>
<p>218是c类，所以剩下8-3位=5位主机号，表示32个地址，也够。</p>
<p>然后这8个子网随便分配就行</p>
<h6 id="变长的子网掩码：VLSM"><a href="#变长的子网掩码：VLSM" class="headerlink" title="变长的子网掩码：VLSM"></a>变长的子网掩码：VLSM</h6><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="file:///D:\Tencent Softwares\QQ\Files\1437290395\Image\C2C\46DA136BE397783D1F503D081E9D1299.png" alt="img"></h4><h4 id="网络地址转换：NAT"><a href="#网络地址转换：NAT" class="headerlink" title="网络地址转换：NAT"></a>网络地址转换：NAT</h4><p>NAT的思想：ISP为每一个家庭或公司分配一个IP地址，这个地址来传输Internet流量。客户网络内部，每台计算机有唯一的IP地址，该地址主要用来路由内部流量，但是想要向其他ISP发送数据时，就得地址转换。</p>
<p>每个NAT都有自己负责的区域，有自己的全局IP地址，一个区域的流量控制只通过一个NAT，那么一个路由器坏掉以后就会造成影响。有备用的也不行</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>地址写法：</p>
<p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210619172033091.png" alt="image-20210619172033091" style="zoom:33%;" /></p>
<p>IPv6省掉了什么：</p>
<p>IHL：因为IPv6有固定长度</p>
<p>协议字段：因为下一个头字段指明了最后的IP头后面跟着什么</p>
<p>所有和分段有关的字段：因为 IPv6采用另一种方法分段</p>
<p>校验和：计算校验和降低性能</p>
<h4 id="Internet控制协议"><a href="#Internet控制协议" class="headerlink" title="Internet控制协议"></a>Internet控制协议</h4><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><p>路由器监视Internet的操作，如果路由器处理包时发生意外，就通过ICMP向源端报告</p>
<p>报文的前4个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的4个字节的内 容与ICMP的类型有关</p>
<h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><p>是一个地址转换协议，每种协议的地址都要转换成对应的数据链路层的 MAC地址。</p>
<h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h5><h2 id="6-Transmission"><a href="#6-Transmission" class="headerlink" title="6-Transmission"></a>6-Transmission</h2><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>使用端口号来表示应用层的不同进程</p>
<p>端口号由16比特，0~65535</p>
<p>端口号只具有本地意义，因特网不同计算机中的相同端口号无联系 </p>
<h3 id="TCP和UDP的区别："><a href="#TCP和UDP的区别：" class="headerlink" title="TCP和UDP的区别："></a>TCP和UDP的区别：</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP数据包中协议字段的值</td>
<td>17</td>
<td>6</td>
</tr>
<tr>
<td>通信双方</td>
<td>随时发送数据</td>
<td>三报文握手，四报文挥手</td>
</tr>
<tr>
<td>面向</td>
<td>应用报文</td>
<td>字节流</td>
</tr>
<tr>
<td>支持通信</td>
<td>可以单播多播广播</td>
<td>只能单播</td>
</tr>
<tr>
<td>对发送方数据的操作</td>
<td>对应用层报文既不合并也不拆分，直接给应用层报文添加UDP首部，使成为UDP用户数据报</td>
<td>把数据块看成字节流，将一定数目的字节构建TCP报文段并发送，不保证数据块对应大小一致，但是要保证顺序，所以要检查</td>
</tr>
<tr>
<td></td>
<td>无连接不可靠</td>
<td>面向连接可靠</td>
</tr>
<tr>
<td>首部大小</td>
<td>8个字节</td>
<td>20-60字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>通过滑动窗口实现</p>
<p>ACK和ack</p>
<p>ACK是TCP报文首段的标志位，取值为1表示这是确认报文段</p>
<p>ack是确认号字段，取值为n标识n之前的全部数据正确接收，是累计确认</p>
<p>TCP为每一个连接设置一个持续计时器：收到零窗口通知时使用，时间到了就发送探测报文段（携带重传计时器）</p>
<p>TCP发送方发送窗口=min[发送方拥塞窗口，接收方接收窗口]</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><h4 id="t吞吐量"><a href="#t吞吐量" class="headerlink" title="t吞吐量"></a>t吞吐量</h4><p>理想：吞吐量饱和之前，吞吐量=输入负载</p>
<p>实际情况：若出现拥塞而不控制，吞吐量随输入负载增大而下降</p>
<h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>指一开始注入的报文段少，不是增长慢</p>
<p>拥塞窗口cwnd是动态变化的</p>
<p>拥塞窗口按指数规律增长</p>
<p>发送方将拥塞窗口当作发送窗口</p>
<p>慢开始门限：ssthresh</p>
<p>拥塞窗口小于慢开始门限时，使用慢开始</p>
<p>拥塞窗口大于慢开始门限时，使用拥塞避免</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>拥塞窗口按线性规律增长，每次加1</p>
<p><strong>重传计时器到时，收到超时重传</strong></p>
<p>慢开始门限值改为原来一半</p>
<p>拥塞窗口值改为1</p>
<h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><p><strong>发送方收到三个连续的重复确认</strong>，相应报文段立即重传，不等计时器。</p>
<p>也就是说发送方会收到四次某个报文段的确认。</p>
<h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p>将慢开始门限值和拥塞窗口值都调整为当前窗口值以一半，直接执行拥塞避免算法</p>
<p>也可以把拥塞窗口值回复到当前窗口一半后再加3，因为减少了三个报文段</p>
<h4 id="题目易错"><a href="#题目易错" class="headerlink" title="题目易错"></a>题目易错</h4><p>发生超时以后第一个RTT，拥塞窗口从1-2。</p>
<h3 id="TCP超时重传时间"><a href="#TCP超时重传时间" class="headerlink" title="TCP超时重传时间"></a>TCP超时重传时间</h3><p>RTO：TCP超时重传时间</p>
<p>RTT：报文段往返时间</p>
<p>RTT~S~：加权平均往返时间</p>
<p>RTT~D~：RTT偏差的加权平均</p>
<p><img src="C:\Users\14372\AppData\Roaming\Typora\typora-user-images\image-20210621163456901.png" alt="image-20210621163456901" style="zoom:50%;" /></p>
<h3 id="TCP运输连接管理"><a href="#TCP运输连接管理" class="headerlink" title="TCP运输连接管理"></a>TCP运输连接管理</h3><h4 id="TCP建立过程：三报文握手"><a href="#TCP建立过程：三报文握手" class="headerlink" title="TCP建立过程：三报文握手"></a>TCP建立过程：三报文握手</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/26/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/" class="post-title-link" itemprop="url">Spring框架学习1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-07-26 09:42:53 / Modified: 09:54:09" itemprop="dateCreated datePublished" datetime="2021-07-26T09:42:53+08:00">2021-07-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、前期准备"><a href="#1、前期准备" class="headerlink" title="1、前期准备"></a>1、前期准备</h2><h3 id="1-1、常用网址"><a href="#1-1、常用网址" class="headerlink" title="1.1、常用网址"></a>1.1、常用网址</h3><p>官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p>
<p>Github下载地址：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/releases">https://github.com/spring-projects/spring-framework/releases</a></p>
<p><img src="https://i.loli.net/2021/07/25/pSx5Gih6kawqe17.png" alt="Github源码包.png" style="zoom:33%;" /></p>
<h3 id="1-2、maven导包"><a href="#1-2、maven导包" class="headerlink" title="1.2、maven导包"></a>1.2、maven导包</h3><p>导包网址：<a target="_blank" rel="noopener" href="https://mvnrepository.com/search?q=spring">https://mvnrepository.com/search?q=spring</a></p>
<p>导入Spring Web MVC包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3、Spring介绍"><a href="#1-3、Spring介绍" class="headerlink" title="1.3、Spring介绍"></a>1.3、Spring介绍</h3><ul>
<li><p>Spring是一个开源的免费框架</p>
</li>
<li><p>Spring是一个轻量级的非入侵式的框架</p>
</li>
<li><p>控制反转（IOC）,面向切面编程（AOP)</p>
</li>
<li><p>七大模块</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/07/25/gDfdUYXApjzmRax.gif" alt="1219227-20170930225010356-45057485.gif"></p>
<ul>
<li><p>三大核心思想</p>
<p>DI(依赖注入), IOC(控制反转) ,AOP(面向切面编程)</p>
</li>
</ul>
<h2 id="2、IOC理论"><a href="#2、IOC理论" class="headerlink" title="2、IOC理论"></a>2、IOC理论</h2><p>IoC是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spriing中实现控制反转的式IoC容器，其实现方法是依赖注入(Dependency Injection  DI)；</p>
<p>可使用Set窗口注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userdao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Set进行动态实现值的注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userdao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userdao = userdao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过配置Bean的定义直接以注解的形式定义在实现类中</p>
<h2 id="3、HelloSpring"><a href="#3、HelloSpring" class="headerlink" title="3、HelloSpring"></a>3、HelloSpring</h2><h3 id="3-1、基于xml的配置元数据的基本结构"><a href="#3-1、基于xml的配置元数据的基本结构" class="headerlink" title="3.1、基于xml的配置元数据的基本结构"></a>3.1、基于xml的配置元数据的基本结构</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;&quot;</span> <span class="attr">value</span> = <span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2、理论知识理解"><a href="#3-2、理论知识理解" class="headerlink" title="3.2、理论知识理解"></a>3.2、理论知识理解</h3><ol>
<li><p>常规的Java源代码需要new对象，格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类 变量名 = <span class="keyword">new</span> 类();</span><br><span class="line"></span><br><span class="line">Hello hello = <span class="keyword">new</span> Hello();</span><br></pre></td></tr></table></figure></li>
<li><p>使用spring时，bean是一个容器，功能可以定义对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;变量名==hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;new的类==Hello在src.main.java下的相对路径&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>property相当于给对象中的属性设定一个值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;&quot;</span> <span class="attr">value</span>/<span class="attr">ref</span> = <span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>name决定Person类中的那个参数对象，也就是通过set方法传入的参数对象名</p>
</li>
<li><p>value和ref</p>
<ol>
<li><p>共同点</p>
<p>都是表示这个参数对象的实际值，这也就是用户通过修改xml文件达到不同目的的关键所在，用户想要啥就把这个改成啥</p>
</li>
<li><p>区别</p>
</li>
</ol>
<p>| ref                                                          | value                                                        |<br>| —————————————————————————————— | —————————————————————————————— |<br>| 引用spring中已有的bean对象                                   | 赋一些简单类型的值和对象的具体值                             |<br>| 使用ref的时候，spring容器会在引用后进行验证，验证当前的xml是否存在引用的bean | 使用value的时候，spring会在容器启动，实例化bean的时候进行验证 |</p>
</li>
</ol>
</li>
<li><p>控制反转</p>
<ol>
<li><p>控制</p>
<p>传统应用对象是程序本身控制创建</p>
<p>Spring的对象是由Spring创建</p>
</li>
<li><p>反转</p>
<p>程序本身不创建对象，成为被动的接受对象</p>
</li>
</ol>
</li>
<li><p>依赖注入</p>
<p>依赖set方法注入</p>
</li>
<li><p>IoC是一种编程思想：由主动创建转变为被动接受，交给Spring</p>
</li>
<li><p>Spring实现托管之后，我们不需要再去程序中改动代码，只需在xml配置文件中进行修改</p>
</li>
</ol>
<h3 id="3-3、初次Spring项目问题及解决方案"><a href="#3-3、初次Spring项目问题及解决方案" class="headerlink" title="3.3、初次Spring项目问题及解决方案"></a>3.3、初次Spring项目问题及解决方案</h3><ol>
<li><p>Lombok插件下载好后导入依赖项失败；</p>
<ul>
<li><p>解决：idea右侧点击maven-&gt;双击clean</p>
<p>​          然后，右击pom.xml的空白处。单击maven下的二级目录中的reimport</p>
<p>​          将版本号由1.16.xx改为1.18.12</p>
</li>
</ul>
</li>
<li><p>为了获取Spring的上下文对象，从官网粘贴如下代码但是缺少相关的jar包；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>解决：在<code>pom.xml</code>文件中导入<code>maven</code>依赖项，并将<code>setting</code>中<code>MAVEN_HONE</code>的地址改为本地地址</li>
</ul>
</li>
<li><p>类被Spring托管之后，类的旁边没有出现叶子符号</p>
<ul>
<li>解决：<code>File-&gt;Project Structure-&gt;Modules</code>，界面中共有三列，中间一列中找到带有绿色叶子符号的<code>Spring</code>并选中，点击右侧出现的<code>+</code>,勾选里面的<code>xml</code>文件，并将其apply</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/20/%E6%8C%87%E9%92%88%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/%E6%8C%87%E9%92%88%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">指针的部分总结（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-20 17:28:22" itemprop="dateCreated datePublished" datetime="2021-02-20T17:28:22+08:00">2021-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-23 23:54:04" itemprop="dateModified" datetime="2021-02-23T23:54:04+08:00">2021-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="四、指针的使用"><a href="#四、指针的使用" class="headerlink" title="四、指针的使用"></a>四、指针的使用</h1><h2 id="5-结构体指针"><a href="#5-结构体指针" class="headerlink" title="5.结构体指针"></a>5.结构体指针</h2><h3 id="1-定义结构的一般形式为："><a href="#1-定义结构的一般形式为：" class="headerlink" title="(1)定义结构的一般形式为："></a>(1)定义结构的一般形式为：</h3><h3 id="struct-结构名"><a href="#struct-结构名" class="headerlink" title="struct    结构名{"></a>struct    结构名{</h3><h3 id="成员列表"><a href="#成员列表" class="headerlink" title="成员列表"></a>成员列表</h3><h3 id="；"><a href="#；" class="headerlink" title="}；"></a>}；</h3><h3 id="2-使用指针来指向结构的解释说明："><a href="#2-使用指针来指向结构的解释说明：" class="headerlink" title="(2)使用指针来指向结构的解释说明："></a>(2)使用指针来指向结构的解释说明：</h3><pre><code>struct guy&#123;
char favfood;
char job;
float income;
&#125;

struct guy fellow[2];/*这是一个结构数组*/
struct guy * him/*声明一个指向结构的指针*/
him=fellow[0]/*告诉指针它指向的地址*/
</code></pre><h3 id="声明指针的语法和其他的指针声明一样，意味着指针him可以指向任何现有的guy类型的结构。而令指针指向fellow-0-则是对该指针的初始化。"><a href="#声明指针的语法和其他的指针声明一样，意味着指针him可以指向任何现有的guy类型的结构。而令指针指向fellow-0-则是对该指针的初始化。" class="headerlink" title="声明指针的语法和其他的指针声明一样，意味着指针him可以指向任何现有的guy类型的结构。而令指针指向fellow[0]则是对该指针的初始化。"></a>声明指针的语法和其他的指针声明一样，意味着指针him可以指向任何现有的guy类型的结构。而令指针指向fellow[0]则是对该指针的初始化。</h3><h3 id="同样的，如果对him加1，那么指针指向的地址就加了1-1-4-6个字节，因为每个结构体占的内存空间为6。"><a href="#同样的，如果对him加1，那么指针指向的地址就加了1-1-4-6个字节，因为每个结构体占的内存空间为6。" class="headerlink" title="同样的，如果对him加1，那么指针指向的地址就加了1+1+4=6个字节，因为每个结构体占的内存空间为6。"></a>同样的，如果对him加1，那么指针指向的地址就加了1+1+4=6个字节，因为每个结构体占的内存空间为6。</h3><h3 id="3-使用指针来访问结构体的成员时有两种方法："><a href="#3-使用指针来访问结构体的成员时有两种方法：" class="headerlink" title="(3)使用指针来访问结构体的成员时有两种方法："></a>(3)使用指针来访问结构体的成员时有两种方法：</h3><h3 id="①结构指针后跟-gt-运算符，而需要注意的是结构名之后则需跟-点-运算符-即"><a href="#①结构指针后跟-gt-运算符，而需要注意的是结构名之后则需跟-点-运算符-即" class="headerlink" title="①结构指针后跟-&gt;运算符，而需要注意的是结构名之后则需跟.(点)运算符,即:"></a>①结构指针后跟-&gt;运算符，而需要注意的是结构名之后则需跟.(点)运算符,即:</h3><pre><code>him-&gt;job is fellow[0].j0b if him == fellow[0]
</code></pre><h3 id="②利用-amp-和-的互逆性-因为him-amp-fellow-0-则有him-fellow-0"><a href="#②利用-amp-和-的互逆性-因为him-amp-fellow-0-则有him-fellow-0" class="headerlink" title="②利用&amp;和 的互逆性,因为him=&amp;fellow[0],则有him=fellow[0]"></a>②利用&amp;和<em> 的互逆性,因为him=&amp;fellow[0],则有</em>him=fellow[0]</h3><h3 id="4-使用指针传递结构成员"><a href="#4-使用指针传递结构成员" class="headerlink" title="(4)使用指针传递结构成员"></a>(4)使用指针传递结构成员</h3><pre><code>#include &lt;stdio.h&gt;

double people(const struct guy *)//people函数使用了指针作为参数

int main()
&#123;
    printf(&quot;%.2f&quot;,people(&amp;him));//把地址&amp;him传给该函数使得指针指向结构him
    return 0;
&#125;

double people(const struct guy * anyone)//确定指针为anyone
&#123;
    return anyone-&gt;job;
&#125;
</code></pre><h3 id="需要注意的是-数组可以通过使用其数组名作为数组地址-但是结构不可以使用结构名作为其地址必须使用-amp-运算符"><a href="#需要注意的是-数组可以通过使用其数组名作为数组地址-但是结构不可以使用结构名作为其地址必须使用-amp-运算符" class="headerlink" title="需要注意的是,数组可以通过使用其数组名作为数组地址,但是结构不可以使用结构名作为其地址必须使用&amp;运算符"></a>需要注意的是,数组可以通过使用其数组名作为数组地址,但是结构不可以使用结构名作为其地址必须使用&amp;运算符</h3><h3 id="5-结构指针与malloc"><a href="#5-结构指针与malloc" class="headerlink" title="(5)结构指针与malloc"></a>(5)结构指针与malloc</h3><h3 id="当我们在结构中使用指针来存储字符串时，例如："><a href="#当我们在结构中使用指针来存储字符串时，例如：" class="headerlink" title="当我们在结构中使用指针来存储字符串时，例如："></a>当我们在结构中使用指针来存储字符串时，例如：</h3><pre><code>struct pnames &#123;
    char * first;
    char * last;
&#125;
</code></pre><h3 id="与常用的字符数组不同的是是现在字符串存储于编译器存储字符的任意位置，不局限于结构内部，这个结构中存放的只有8字节的地址信息。"><a href="#与常用的字符数组不同的是是现在字符串存储于编译器存储字符的任意位置，不局限于结构内部，这个结构中存放的只有8字节的地址信息。" class="headerlink" title="与常用的字符数组不同的是是现在字符串存储于编译器存储字符的任意位置，不局限于结构内部，这个结构中存放的只有8字节的地址信息。"></a>与常用的字符数组不同的是是现在字符串存储于编译器存储字符的任意位置，不局限于结构内部，这个结构中存放的只有8字节的地址信息。</h3><h3 id="但是需要注意的是，pnames结构并不会为字符串分配空间，为了避免出错，first，last所指向的字符串一定是在程序其他地方已经分配过空间，这里我们经常用的方法是使用malloc-分配内存。"><a href="#但是需要注意的是，pnames结构并不会为字符串分配空间，为了避免出错，first，last所指向的字符串一定是在程序其他地方已经分配过空间，这里我们经常用的方法是使用malloc-分配内存。" class="headerlink" title="但是需要注意的是，pnames结构并不会为字符串分配空间，为了避免出错，first，last所指向的字符串一定是在程序其他地方已经分配过空间，这里我们经常用的方法是使用malloc()分配内存。"></a>但是需要注意的是，pnames结构并不会为字符串分配空间，为了避免出错，first，last所指向的字符串一定是在程序其他地方已经分配过空间，这里我们经常用的方法是使用malloc()分配内存。</h3><pre><code>pnames-&gt;first=(char*)malloc(sizeof(char))//成员指针被分配内存
free(pnames-&gt;first)//不要忘记free掉不用的内存
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/12/%E6%8C%87%E9%92%88%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/%E6%8C%87%E9%92%88%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">指针的部分总结（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-12 13:59:41" itemprop="dateCreated datePublished" datetime="2021-01-12T13:59:41+08:00">2021-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-25 23:30:49" itemprop="dateModified" datetime="2021-07-25T23:30:49+08:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>指针是C语言的关键所在，可以说掌握了指针就打通了学习C语言的经脉。作为C语言的特点也是难点，一部分同学在学习指针的时候会感觉云里雾里，希望我的博客会对学习困难的同学有一定帮助。大家一起加油(ง •_•)ง！</p>
<hr>
<h2 id="一、指针是什么："><a href="#一、指针是什么：" class="headerlink" title="一、指针是什么："></a>一、指针是什么：</h2><p>指针其实也是一种变量，与int、char一样，代表的是不同的数据类型。只是int类型变量以整数作为其数值，char类型变量以字符作为其数值，而指针变量的数值是地址。所以指针也可以进行一系列变量可以进行的操作，比如对指针赋值，指针的加减，两个指针大小的比较（同类型）等等。</p>
<hr>
<h2 id="二、为什么要学习指针-："><a href="#二、为什么要学习指针-：" class="headerlink" title="二、为什么要学习指针 #："></a>二、为什么要学习指针 #：</h2><p>这里有一个很多人问的问题：我们到底为什么需要指针，直接用变量名对数值进行操作不就可以了吗？</p>
<p>用变量名当然可以，但是只是用变量名会出现很多bug，因为人脑的思维方式和电脑的运作方式不一样。我们知道int代表整数啊，char代表字符啊，但是计算机不知道，计算机只知道地址和指令（这个也是当本菜鸡学习汇编指令之后才明白的）。</p>
<p>当我们查看编译之后的代码时，它长这样：</p>
<p><img src="https://i.loli.net/2021/01/12/c1eigSFwhr9YNlj.png" style="zoom:50%;" /></p>
<p>这里并没有我们习以为常的各种变量名，只有一系列抽象的数字串。所以在处理一些复杂项目的时候，全篇使用变量名可能会出现一些让人摸不着头脑的bug，而这些错误的源头位置也较难发现。</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2760428880,4127050796&fm=26&gp=0.jpg" style="zoom:25%;" /></p>
<p>这样说还是抽象了点，接下来举个栗子：</p>
<p><img src="https://i.loli.net/2021/01/12/o5HTvUbYjl4D6CF.png" style="zoom: 33%;" /></p>
<p>如图是李明的部分代码，他在主函数中定义了整型变量a之后，在函数fun1中对a进行了修改，但在输出结果中，a的值没有改变。像这样，多个函数要对同一个数据进行读写操作的时候就需要用到指针。</p>
<p>需要理解的是，在函数中对数据的改动只是对数据副本的更改，原本不动。如果想要对原值进行修改，就需要传入数据的地址，这样程序才能找到地址将其修改</p>
<hr>
<h2 id="三、对某个特定指针的理解："><a href="#三、对某个特定指针的理解：" class="headerlink" title="三、对某个特定指针的理解："></a>三、对某个特定指针的理解：</h2><h3 id="1-个人认为，学好指针的关键在于对计算机内存的理解。"><a href="#1-个人认为，学好指针的关键在于对计算机内存的理解。" class="headerlink" title="1. 个人认为，学好指针的关键在于对计算机内存的理解。"></a>1. 个人认为，学好指针的关键在于对计算机内存的理解。</h3><p>计算机的内存是用于储存数据的空间，空间的分布是建立在字节(byte)和位(bit)的概念之上的。一个位能表示0/1两个状态，而一个字节是一个8位的块，大多数计算机将字节作为最小的可寻址内存单位。不同的数据类型的占用内存的大小不同，int类型的数据占用4字节的内存而char类型的数据占用1字节的内存。</p>
<p><img src="https://i.loli.net/2021/01/12/4FB6Edy8fmUkbVn.png" style="zoom:33%;" /></p>
<p>当我们声明一个变量的时候，实际上是向内存申请了一块空间来存放数据，而一个指针存储的数据就是该指针所指向变量的起始地址。</p>
<h3 id="2-当我们看到一个指针的时候，需要搞定四道关卡：指针的类型、指针所指数据的类型、指针的值、指针本身所占的内存。"><a href="#2-当我们看到一个指针的时候，需要搞定四道关卡：指针的类型、指针所指数据的类型、指针的值、指针本身所占的内存。" class="headerlink" title="2.当我们看到一个指针的时候，需要搞定四道关卡：指针的类型、指针所指数据的类型、指针的值、指针本身所占的内存。"></a>2.当我们看到一个指针的时候，需要搞定四道关卡：指针的类型、指针所指数据的类型、指针的值、指针本身所占的内存。</h3><p>首先说用到最多的：指针的类型和指针所指数据的类型。</p>
<p>从语法的角度看，将声明语句中指针的名字去掉剩下的就是指针的类型，而将指针名字以及其左边的指针声明符*去掉之后剩下的就是指针指向数据的类型。</p>
<p>接下来还是举一些例子：</p>
<p>(1)<code>int *ptr</code></p>
<p>指针类型：<code>int*</code></p>
<p>指针指向数据类型：<code>int</code></p>
<p>(2)    <code>char *ptr</code></p>
<p>指针类型：<code>char*</code></p>
<p>指针指向数据类型：<code>char</code></p>
<p>(3)    <code>int **ptr</code></p>
<p>指针类型：<code>int**</code></p>
<p>指针指向数据类型：<code>int*</code></p>
<p>(4)    <code>int(*ptr)[3]</code></p>
<p>指针类型：<code>int*[3]</code></p>
<p>指针指向数据类型：<code>int[3]</code></p>
<p>在这个例子中，从名称ptr出发，ptr先与<em>结合(加括号的原因是[ ]优先级高于 </em>，所以分析的时候可以去掉括号)，说明ptr是一个指针，指针与[]结合说明指针指向的内容是数组，然后与int结合说明数组元素是整型，所以p是指向整型数组的指针。</p>
<p>与指向数组的指针相对应的是指针数组：int*ptr[3]</p>
<p>因为ptr首先与[ ]结合，所以ptr是一个数组，然后与*结合，说明这个数组中的元素是指针，然后与int结合，说明指针指向的是内容是整型。所以这是一个指向整型数据的指针组成的数组。</p>
<p>(5)    <code>int *(*ptr)[4]</code></p>
<p>指针类型：<code>int**[4]</code></p>
<p>指针指向数据类型：<code>int*[4]</code></p>
<p>通过上一个例子的解释，例(5)就很明了是指向数组的指针，而这个数组是由指向整型数据的指针组成的。</p>
<p>接下来要讨论的是指针的值，我们说指针中存储的是地址，所以指针的值就是地址的大小。即为指针所指向的数据的起始地址。</p>
<p>指针本身所占的内存大小也就是说指针这种变量类型的字长，在64位机器(大部分机器)中是八字节。</p>
<hr>
<h2 id="四、指针的使用："><a href="#四、指针的使用：" class="headerlink" title="四、指针的使用："></a>四、指针的使用：</h2><h3 id="1、首先必须强调的一点是绝对不能对未初始化的指针取值！！！"><a href="#1、首先必须强调的一点是绝对不能对未初始化的指针取值！！！" class="headerlink" title="1、首先必须强调的一点是绝对不能对未初始化的指针取值！！！"></a>1、首先必须强调的一点是绝对不能对未初始化的指针取值！！！</h3><p>形如</p>
<p><code>int *ptr; 
*ptr=5;</code></p>
<p>这样的未初始化的指针我们称之为“野指针”，其危害性极大。第二句表示将数值5存储在指针ptr所指向的地址中，但是因为指针未初始化，所以其值是随机的，我们不知道5会被存到什么位置。也许会存到某个已经有程序数据的地址，这样做的后果是原有的数据会被覆盖，可能导致程序崩溃。</p>
<p>指针需要初始化的原因在于当创建指针的时候，系统之分配了用来存储指针本身的内存空间。并没有给它分配存储数据的内存空间。因此在使用指针之前，必须给它赋予一个已经分配的内存地址用来存储数据。 </p>
<hr>
<h3 id="2、运算符：-amp-和-（作为单目运算符"><a href="#2、运算符：-amp-和-（作为单目运算符" class="headerlink" title="2、运算符：&amp;和*（作为单目运算符)"></a>2、运算符：&amp;和*（作为单目运算符)</h3><p>&amp;即为取址运算符，对一个变量a进行取址运算&amp;a得到的是a的地址，即&amp;a成为了指针变量。</p>
<p>*是间接运算符，用来拿到一个指针所指向地址的内容。</p>
<hr>
<h3 id="3、数组与指针及数组的算术运算："><a href="#3、数组与指针及数组的算术运算：" class="headerlink" title="3、数组与指针及数组的算术运算："></a>3、数组与指针及数组的算术运算：</h3><p>数组标记其实是对指针的变相使用。对于数组：data[int size]，数组名data实际上就是该数组首元素的地址，即数组名就是指向数组起始元素的指针：data = = &amp;data[0]。</p>
<p>在C语言中，对指针加1的结果是对该指针增加一个存储空间(即sizeof((指针指向的数据类型))。所以对一个数组data[size]来说，*(data+1)=data[1]。但是对于非数组指针来说，情况就会变得不太一样。</p>
<p>举个栗子：</p>
<p><img src="https://i.loli.net/2021/01/12/c438mSg9XwWE5hR.png" style="zoom:33%;" /></p>
<p>思考一下会输出什么？</p>
<p>————————————————————————我是一道分隔符————————————————————————</p>
<p>答案是：未知数</p>
<p><img src="http://img.doutula.com/production/uploads/image/2019/07/08/20190708533814_FlUARy.jpg" style="zoom:25%;" /></p>
<p>我们来分析一下ptr这个指针,它的类型是char <em>* ，所指向的类型是char </em> ，所以当ptr执行递增操作时，指针会增加一个sizeof(char*)即指针原来指向的地址+8.数组是一系列连续排列的地址,但是指向数组的指针的地址可并不是连续排列的,而指针的地址+8，谁都不知道会指向哪里。 </p>
<hr>
<h3 id="4、指针与多维数组"><a href="#4、指针与多维数组" class="headerlink" title="4、指针与多维数组"></a>4、指针与多维数组</h3><p>假设有声明：<code>int zippo[4][2]</code></p>
<p>那么有这么几个概念：zippo,zippo[0],zippo[0][0]</p>
<p>zippo是数组首元素地址，所以zippo=&amp;zippo[0]。</p>
<p>而zippo[0]是包含两个整数的数组名，所以zippo[0]=&amp;zippo[0][0]。</p>
<p>因为整数和两个整数组成的数组开始的地址相同，所以zippo=zippo[0]，两者数值一致。</p>
<p>那么来判断一下<code>zippo+1==zippo[0]+1</code>这句代码的正确性</p>
<p>答案是否定的。zippo指向的是一个由两个整数组成的数组，zippo[0]指向的是一个整数，所以<code>zippo+1</code>是原值+8(2*4)，而<code>zippo[0]+1</code>则是原值+4</p>
<p>当用指针符号表示时，</p>
<p><code>zippo==zippo[0]</code></p>
<p><code>*zippo==zippo[0]==&amp;zippo[0][0]</code></p>
<p><code>**zippo==*zippo[0]==zippo[0][0]</code></p>
<p><code>zippo[2][1]==*(*(zippo+2)+1)</code></p>
<p>对于最后一行等式，如果不理解可以看这里：</p>
<p><table>
  <tr>
      <td>zippo</td>
      <td>第一个一维数组的首元素地址</td>
  </tr>
  <tr>
      <td>zippo+2</td>
      <td>第三个一维数组的首元素地址</td>
  </tr>
 <tr>
      <td>*(zippo+2)</td>
      <td>第三个一维数组的首元素地址,和zippo+2的区别在于类型转变了</td>
  </tr>
 <tr>
      <td>*(zippo+2)+1</td>
      <td>第三个一维数组的第二个元素的地址</td>
  </tr>
 <tr>
      <td>*(*(zippo+2)+1)</td>
      <td>第三个一维数组的第二个元素的值</td>
  </tr>
</table></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/11/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-11 08:28:52" itemprop="dateCreated datePublished" datetime="2021-01-11T08:28:52+08:00">2021-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
